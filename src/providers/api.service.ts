/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.13.2.0 (NJsonSchema v9.10.21.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://reservation.squash-arena.ch:4430";
    }

    /**
     * get all actions
     * @return OK
     */
    actions_GetAll(): Observable<DomainActionView[]> {
        let url_ = this.baseUrl + "/api/actions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processActions_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActions_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView[]>><any>Observable.throw(response_);
        });
    }

    protected processActions_GetAll(response: HttpResponseBase): Observable<DomainActionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DomainActionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView[]>(<any>null);
    }

    /**
     * update an Action
     * @return OK
     */
    actions_Put(updateActionView: DomainActionView): Observable<any> {
        let url_ = this.baseUrl + "/api/actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateActionView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processActions_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActions_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processActions_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an Action
     * @return OK
     */
    actions_Post(view: DomainActionView): Observable<number> {
        let url_ = this.baseUrl + "/api/actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processActions_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActions_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processActions_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get an Action by id
     * @return OK
     */
    actions_Get(actionId: number): Observable<DomainActionView> {
        let url_ = this.baseUrl + "/api/actions/{ActionId}";
        if (actionId === undefined || actionId === null)
            throw new Error("The parameter 'actionId' must be defined.");
        url_ = url_.replace("{ActionId}", encodeURIComponent("" + actionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processActions_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActions_Get(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView>><any>Observable.throw(response_);
        });
    }

    protected processActions_Get(response: HttpResponseBase): Observable<DomainActionView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainActionView.fromJS(resultData200) : new DomainActionView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView>(<any>null);
    }

    /**
     * delete an Action
     * @id id of the record to delete
     * @return OK
     */
    actions_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/actions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processActions_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActions_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processActions_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get events for certain time and resource or organisation
     * @start start date
     * @end end date
     * @eventOrganisationId (optional) event organisation
     * @resourceId (optional) resource id
     * @participantId (optional) filter for this participant
     * @freeOnly (optional) only return free events
     * @return OK
     */
    calendar_Query(start: Date, end: Date, eventOrganisationId: number | null | undefined, resourceId: number | null | undefined, participantId: string | null | undefined, freeOnly: boolean | null | undefined): Observable<CalendarView[]> {
        let url_ = this.baseUrl + "/api/calendar?";
        if (start === undefined || start === null)
            throw new Error("The parameter 'start' must be defined and cannot be null.");
        else
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === undefined || end === null)
            throw new Error("The parameter 'end' must be defined and cannot be null.");
        else
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        if (eventOrganisationId !== undefined)
            url_ += "eventOrganisationId=" + encodeURIComponent("" + eventOrganisationId) + "&"; 
        if (resourceId !== undefined)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&"; 
        if (participantId !== undefined)
            url_ += "participantId=" + encodeURIComponent("" + participantId) + "&"; 
        if (freeOnly !== undefined)
            url_ += "freeOnly=" + encodeURIComponent("" + freeOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processCalendar_Query(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalendar_Query(<any>response_);
                } catch (e) {
                    return <Observable<CalendarView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CalendarView[]>><any>Observable.throw(response_);
        });
    }

    protected processCalendar_Query(response: HttpResponseBase): Observable<CalendarView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CalendarView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CalendarView[]>(<any>null);
    }

    /**
     * get all participants for a certain event
     * @return OK
     */
    eventParticipants_GetByEvent(eventId: string): Observable<EventParticipantView[]> {
        let url_ = this.baseUrl + "/api/events/{eventId}/participants";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_GetByEvent(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_GetByEvent(<any>response_);
                } catch (e) {
                    return <Observable<EventParticipantView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventParticipantView[]>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_GetByEvent(response: HttpResponseBase): Observable<EventParticipantView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventParticipantView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventParticipantView[]>(<any>null);
    }

    /**
     * update a participant from an event
     * @return OK
     */
    eventParticipants_Put(updateEventParticipantsView: EventParticipantView, eventId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/participants";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateEventParticipantsView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * add a participant to an event
     * @return OK
     */
    eventParticipants_Post(view: EventParticipantView, eventId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/participants";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_Post(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_Post(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get an event participant by event id and participant id
     * @return OK
     */
    eventParticipants_Get(eventId: string, participantId: string): Observable<EventParticipantView> {
        let url_ = this.baseUrl + "/api/events/{eventId}/participants/{participantId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        if (participantId === undefined || participantId === null)
            throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace("{participantId}", encodeURIComponent("" + participantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_Get(<any>response_);
                } catch (e) {
                    return <Observable<EventParticipantView>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventParticipantView>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_Get(response: HttpResponseBase): Observable<EventParticipantView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventParticipantView.fromJS(resultData200) : new EventParticipantView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventParticipantView>(<any>null);
    }

    /**
     * remove a participant from an event
     * @eventId id of the event to delete participant from
     * @participantId id of the participant to delete
     * @return OK
     */
    eventParticipants_Delete(eventId: string, participantId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/participants/{participantId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        if (participantId === undefined || participantId === null)
            throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace("{participantId}", encodeURIComponent("" + participantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get calculations which are visible for an event participant
     * @participantId unique id of event participant
     * @return OK
     */
    eventParticipants_GetCalculations(participantId: number): Observable<DomainActionView[]> {
        let url_ = this.baseUrl + "/api/events/participants/{participantId}/calculations";
        if (participantId === undefined || participantId === null)
            throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace("{participantId}", encodeURIComponent("" + participantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventParticipants_GetCalculations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventParticipants_GetCalculations(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView[]>><any>Observable.throw(response_);
        });
    }

    protected processEventParticipants_GetCalculations(response: HttpResponseBase): Observable<DomainActionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DomainActionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView[]>(<any>null);
    }

    /**
     * get all resources for a certain event
     * @return OK
     */
    eventResources_GetByEvent(eventId: string): Observable<EventResourceView[]> {
        let url_ = this.baseUrl + "/api/events/{eventId}/resources";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventResources_GetByEvent(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventResources_GetByEvent(<any>response_);
                } catch (e) {
                    return <Observable<EventResourceView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventResourceView[]>><any>Observable.throw(response_);
        });
    }

    protected processEventResources_GetByEvent(response: HttpResponseBase): Observable<EventResourceView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventResourceView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventResourceView[]>(<any>null);
    }

    /**
     * update a resource from an event
    the resource id has to be in the view
     * @return OK
     */
    eventResources_Put(view: EventResourceView, eventId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/resources";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processEventResources_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventResources_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventResources_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * add a resource to an event
     * @return OK
     */
    eventResources_Post(view: EventResourceView, eventId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/resources";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEventResources_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventResources_Post(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventResources_Post(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get an event resource by event id and resource id
     * @return OK
     */
    eventResources_Get(eventId: string, resourceId: number): Observable<EventResourceView> {
        let url_ = this.baseUrl + "/api/events/{eventId}/resources/{resourceId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventResources_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventResources_Get(<any>response_);
                } catch (e) {
                    return <Observable<EventResourceView>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventResourceView>><any>Observable.throw(response_);
        });
    }

    protected processEventResources_Get(response: HttpResponseBase): Observable<EventResourceView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventResourceView.fromJS(resultData200) : new EventResourceView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventResourceView>(<any>null);
    }

    /**
     * remove a resource from an event
     * @eventId id of the event to delete resource from
     * @resourceId id of the resource to delete
     * @return OK
     */
    eventResources_Delete(eventId: string, resourceId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{eventId}/resources/{resourceId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processEventResources_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventResources_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventResources_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * seed predefined events for a season
     * @organisationId organisation id
     * @seasonStart start date to seed
     * @seasonEnd end date to seed until
     * @return OK
     */
    events_Seed(organisationId: number, seasonStart: Date, seasonEnd: Date): Observable<any> {
        let url_ = this.baseUrl + "/api/events/seed/{organisationId}?";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        if (seasonStart === undefined || seasonStart === null)
            throw new Error("The parameter 'seasonStart' must be defined and cannot be null.");
        else
            url_ += "seasonStart=" + encodeURIComponent(seasonStart ? "" + seasonStart.toJSON() : "") + "&"; 
        if (seasonEnd === undefined || seasonEnd === null)
            throw new Error("The parameter 'seasonEnd' must be defined and cannot be null.");
        else
            url_ += "seasonEnd=" + encodeURIComponent(seasonEnd ? "" + seasonEnd.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_Seed(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_Seed(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEvents_Seed(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * create exceptions for a holiday
     * @organisationId organisation id
     * @holidayDate date of holiday
     * @return OK
     */
    events_SeedHoliday(organisationId: number, holidayDate: Date): Observable<any> {
        let url_ = this.baseUrl + "/api/events/seed/{organisationId}/holiday/{holidayDate}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        if (holidayDate === undefined || holidayDate === null)
            throw new Error("The parameter 'holidayDate' must be defined.");
        url_ = url_.replace("{holidayDate}", encodeURIComponent(holidayDate ? "" + holidayDate.toJSON() : "null")); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_SeedHoliday(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_SeedHoliday(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEvents_SeedHoliday(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all events owned by an organisation
     * @start (optional) 
     * @end (optional) 
     * @return OK
     */
    events_GetByOwner(organisationId: number, start: Date | null | undefined, end: Date | null | undefined): Observable<EventView[]> {
        let url_ = this.baseUrl + "/api/events/resourceowner/{organisationId}?";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_GetByOwner(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_GetByOwner(<any>response_);
                } catch (e) {
                    return <Observable<EventView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventView[]>><any>Observable.throw(response_);
        });
    }

    protected processEvents_GetByOwner(response: HttpResponseBase): Observable<EventView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventView[]>(<any>null);
    }

    /**
     * get events by multiple criteria
     * @eventId (optional) id of event
     * @resourceOrganisationId (optional) filter by resources owned by this organsiation
     * @eventOrganisationId (optional) id of organisation owning event type
     * @participantId (optional) id of participant
     * @subscriptionInstanceId (optional) subscription instance id of event participants
     * @start (optional) start date
     * @end (optional) end date
     * @return OK
     */
    events_GetAll(eventId: string | null | undefined, resourceOrganisationId: number | null | undefined, eventOrganisationId: number | null | undefined, participantId: string | null | undefined, subscriptionInstanceId: number | null | undefined, start: Date | null | undefined, end: Date | null | undefined): Observable<EventView[]> {
        let url_ = this.baseUrl + "/api/events?";
        if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&"; 
        if (resourceOrganisationId !== undefined)
            url_ += "resourceOrganisationId=" + encodeURIComponent("" + resourceOrganisationId) + "&"; 
        if (eventOrganisationId !== undefined)
            url_ += "eventOrganisationId=" + encodeURIComponent("" + eventOrganisationId) + "&"; 
        if (participantId !== undefined)
            url_ += "participantId=" + encodeURIComponent("" + participantId) + "&"; 
        if (subscriptionInstanceId !== undefined)
            url_ += "subscriptionInstanceId=" + encodeURIComponent("" + subscriptionInstanceId) + "&"; 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<EventView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventView[]>><any>Observable.throw(response_);
        });
    }

    protected processEvents_GetAll(response: HttpResponseBase): Observable<EventView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventView[]>(<any>null);
    }

    /**
     * update an Event
     * @return OK
     */
    events_Put(updateEventView: EventView): Observable<any> {
        let url_ = this.baseUrl + "/api/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateEventView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEvents_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an Event
     * @return OK
     */
    events_Post(view: EventView): Observable<string> {
        let url_ = this.baseUrl + "/api/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_Post(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processEvents_Post(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string>(<any>null);
    }

    /**
     * get an Event by id
     * @return OK
     */
    events_Get(eventId: string): Observable<EventView> {
        let url_ = this.baseUrl + "/api/events/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_Get(<any>response_);
                } catch (e) {
                    return <Observable<EventView>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventView>><any>Observable.throw(response_);
        });
    }

    protected processEvents_Get(response: HttpResponseBase): Observable<EventView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventView.fromJS(resultData200) : new EventView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventView>(<any>null);
    }

    /**
     * delete an Event
     * @id id of the record to delete
     * @return OK
     */
    events_Delete(id: string): Observable<any> {
        let url_ = this.baseUrl + "/api/events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processEvents_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvents_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEvents_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all event types
     * @return OK
     */
    eventTypes_GetAll(): Observable<EventTypeView[]> {
        let url_ = this.baseUrl + "/api/eventtypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventTypes_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypes_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<EventTypeView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventTypeView[]>><any>Observable.throw(response_);
        });
    }

    protected processEventTypes_GetAll(response: HttpResponseBase): Observable<EventTypeView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventTypeView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventTypeView[]>(<any>null);
    }

    /**
     * update an EventType
     * @return OK
     */
    eventTypes_Put(updateEventTypeView: EventTypeView): Observable<any> {
        let url_ = this.baseUrl + "/api/eventtypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateEventTypeView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processEventTypes_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypes_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventTypes_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an EventType
     * @return OK
     */
    eventTypes_Post(view: EventTypeView): Observable<number> {
        let url_ = this.baseUrl + "/api/eventtypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processEventTypes_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypes_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processEventTypes_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get an EventType by id
     * @return OK
     */
    eventTypes_Get(eventTypeId: number): Observable<EventTypeView> {
        let url_ = this.baseUrl + "/api/eventtypes/{eventTypeId}";
        if (eventTypeId === undefined || eventTypeId === null)
            throw new Error("The parameter 'eventTypeId' must be defined.");
        url_ = url_.replace("{eventTypeId}", encodeURIComponent("" + eventTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processEventTypes_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypes_Get(<any>response_);
                } catch (e) {
                    return <Observable<EventTypeView>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventTypeView>><any>Observable.throw(response_);
        });
    }

    protected processEventTypes_Get(response: HttpResponseBase): Observable<EventTypeView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventTypeView.fromJS(resultData200) : new EventTypeView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EventTypeView>(<any>null);
    }

    /**
     * delete an EventType
     * @id id of the record to delete
     * @return OK
     */
    eventTypes_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/eventtypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processEventTypes_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventTypes_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processEventTypes_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all organsiations
     * @return OK
     */
    organisations_GetAll(): Observable<OrganisationView[]> {
        let url_ = this.baseUrl + "/api/organisations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisations_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisations_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<OrganisationView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganisationView[]>><any>Observable.throw(response_);
        });
    }

    protected processOrganisations_GetAll(response: HttpResponseBase): Observable<OrganisationView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganisationView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganisationView[]>(<any>null);
    }

    /**
     * update an organisation
     * @return OK
     */
    organisations_Put(updateOrganisationView: OrganisationView): Observable<any> {
        let url_ = this.baseUrl + "/api/organisations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateOrganisationView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisations_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisations_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processOrganisations_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an organisation
     * @return OK
     */
    organisations_Post(view: OrganisationView): Observable<number> {
        let url_ = this.baseUrl + "/api/organisations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisations_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisations_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processOrganisations_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get an organisation by id
     * @return OK
     */
    organisations_Get(organisationId: number): Observable<OrganisationView> {
        let url_ = this.baseUrl + "/api/organisations/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisations_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisations_Get(<any>response_);
                } catch (e) {
                    return <Observable<OrganisationView>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganisationView>><any>Observable.throw(response_);
        });
    }

    protected processOrganisations_Get(response: HttpResponseBase): Observable<OrganisationView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganisationView.fromJS(resultData200) : new OrganisationView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganisationView>(<any>null);
    }

    /**
     * delete an organisation
     * @id id of the record to delete
     * @return OK
     */
    organisations_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/organisations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisations_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisations_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processOrganisations_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all organisation types
     * @return OK
     */
    organisationTypes_GetAll(): Observable<OrganisationTypeView[]> {
        let url_ = this.baseUrl + "/api/organisationtypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisationTypes_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisationTypes_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<OrganisationTypeView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganisationTypeView[]>><any>Observable.throw(response_);
        });
    }

    protected processOrganisationTypes_GetAll(response: HttpResponseBase): Observable<OrganisationTypeView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganisationTypeView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganisationTypeView[]>(<any>null);
    }

    /**
     * update an OrganisationType
     * @return OK
     */
    organisationTypes_Put(updateOrganisationTypeView: OrganisationTypeView): Observable<any> {
        let url_ = this.baseUrl + "/api/organisationtypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateOrganisationTypeView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisationTypes_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisationTypes_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processOrganisationTypes_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an OrganisationType
     * @return OK
     */
    organisationTypes_Post(view: OrganisationTypeView): Observable<number> {
        let url_ = this.baseUrl + "/api/organisationtypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisationTypes_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisationTypes_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processOrganisationTypes_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get an OrganisationType by id
     * @return OK
     */
    organisationTypes_Get(organisationTypeId: number): Observable<OrganisationTypeView> {
        let url_ = this.baseUrl + "/api/organisationtypes/{organisationTypeId}";
        if (organisationTypeId === undefined || organisationTypeId === null)
            throw new Error("The parameter 'organisationTypeId' must be defined.");
        url_ = url_.replace("{organisationTypeId}", encodeURIComponent("" + organisationTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisationTypes_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisationTypes_Get(<any>response_);
                } catch (e) {
                    return <Observable<OrganisationTypeView>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganisationTypeView>><any>Observable.throw(response_);
        });
    }

    protected processOrganisationTypes_Get(response: HttpResponseBase): Observable<OrganisationTypeView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganisationTypeView.fromJS(resultData200) : new OrganisationTypeView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganisationTypeView>(<any>null);
    }

    /**
     * delete an OrganisationType
     * @id id of the record to delete
     * @return OK
     */
    organisationTypes_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/organisationtypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processOrganisationTypes_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganisationTypes_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processOrganisationTypes_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all payment gateways
     * @return OK
     */
    paymentGateways_GetAll(): Observable<PaymentGatewayView[]> {
        let url_ = this.baseUrl + "/api/paymentgateways";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processPaymentGateways_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentGateways_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentGatewayView[]>><any>Observable.throw(response_);
        });
    }

    protected processPaymentGateways_GetAll(response: HttpResponseBase): Observable<PaymentGatewayView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PaymentGatewayView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PaymentGatewayView[]>(<any>null);
    }

    /**
     * update an PaymentGateway
     * @return OK
     */
    paymentGateways_Put(updatePaymentGatewayView: PaymentGatewayView): Observable<any> {
        let url_ = this.baseUrl + "/api/paymentgateways";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatePaymentGatewayView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processPaymentGateways_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentGateways_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPaymentGateways_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert a PaymentGateway
     * @return OK
     */
    paymentGateways_Post(view: PaymentGatewayView): Observable<number> {
        let url_ = this.baseUrl + "/api/paymentgateways";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processPaymentGateways_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentGateways_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processPaymentGateways_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get a PaymentGateway by id
     * @return OK
     */
    paymentGateways_Get(eventTypeId: number): Observable<PaymentGatewayView> {
        let url_ = this.baseUrl + "/api/paymentgateways/{eventTypeId}";
        if (eventTypeId === undefined || eventTypeId === null)
            throw new Error("The parameter 'eventTypeId' must be defined.");
        url_ = url_.replace("{eventTypeId}", encodeURIComponent("" + eventTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processPaymentGateways_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentGateways_Get(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayView>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentGatewayView>><any>Observable.throw(response_);
        });
    }

    protected processPaymentGateways_Get(response: HttpResponseBase): Observable<PaymentGatewayView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentGatewayView.fromJS(resultData200) : new PaymentGatewayView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PaymentGatewayView>(<any>null);
    }

    /**
     * delete an PaymentGateway
     * @id id of the record to delete
     * @return OK
     */
    paymentGateways_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/paymentgateways/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processPaymentGateways_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentGateways_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPaymentGateways_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all postings
     * @return OK
     */
    postings_GetAll(): Observable<PostingView[]> {
        let url_ = this.baseUrl + "/api/postings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<PostingView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostingView[]>><any>Observable.throw(response_);
        });
    }

    protected processPostings_GetAll(response: HttpResponseBase): Observable<PostingView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PostingView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostingView[]>(<any>null);
    }

    /**
     * update a Posting
     * @return OK
     */
    postings_Put(view: PostingView): Observable<any> {
        let url_ = this.baseUrl + "/api/postings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert Posting
     * @return OK
     */
    postings_Post(view: PostingView): Observable<number> {
        let url_ = this.baseUrl + "/api/postings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get a posting by its id
     * @return OK
     */
    postings_Get(postingId: number): Observable<PostingView> {
        let url_ = this.baseUrl + "/api/postings/{postingId}";
        if (postingId === undefined || postingId === null)
            throw new Error("The parameter 'postingId' must be defined.");
        url_ = url_.replace("{postingId}", encodeURIComponent("" + postingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Get(<any>response_);
                } catch (e) {
                    return <Observable<PostingView>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostingView>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Get(response: HttpResponseBase): Observable<PostingView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostingView.fromJS(resultData200) : new PostingView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostingView>(<any>null);
    }

    /**
     * query postings
     * @organisationId (optional) 
     * @posted (optional) 
     * @eventId (optional) 
     * @resourceId (optional) 
     * @valueDateFrom (optional) 
     * @valueDateTo (optional) 
     * @ledgerAccountNo (optional) 
     * @paymentGatewayId (optional) 
     * @paymentReference (optional) 
     * @subscriptionInstanceId (optional) 
     * @return OK
     */
    postings_Query(organisationId: number | null | undefined, posted: boolean | null | undefined, eventId: string | null | undefined, resourceId: number | null | undefined, valueDateFrom: Date | null | undefined, valueDateTo: Date | null | undefined, ledgerAccountNo: string | null | undefined, paymentGatewayId: number | null | undefined, paymentReference: string | null | undefined, subscriptionInstanceId: number | null | undefined): Observable<PostingView[]> {
        let url_ = this.baseUrl + "/api/postings/query?";
        if (organisationId !== undefined)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        if (posted !== undefined)
            url_ += "posted=" + encodeURIComponent("" + posted) + "&"; 
        if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&"; 
        if (resourceId !== undefined)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&"; 
        if (valueDateFrom !== undefined)
            url_ += "valueDateFrom=" + encodeURIComponent(valueDateFrom ? "" + valueDateFrom.toJSON() : "") + "&"; 
        if (valueDateTo !== undefined)
            url_ += "valueDateTo=" + encodeURIComponent(valueDateTo ? "" + valueDateTo.toJSON() : "") + "&"; 
        if (ledgerAccountNo !== undefined)
            url_ += "ledgerAccountNo=" + encodeURIComponent("" + ledgerAccountNo) + "&"; 
        if (paymentGatewayId !== undefined)
            url_ += "paymentGatewayId=" + encodeURIComponent("" + paymentGatewayId) + "&"; 
        if (paymentReference !== undefined)
            url_ += "paymentReference=" + encodeURIComponent("" + paymentReference) + "&"; 
        if (subscriptionInstanceId !== undefined)
            url_ += "subscriptionInstanceId=" + encodeURIComponent("" + subscriptionInstanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Query(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Query(<any>response_);
                } catch (e) {
                    return <Observable<PostingView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostingView[]>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Query(response: HttpResponseBase): Observable<PostingView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PostingView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostingView[]>(<any>null);
    }

    /**
     * delete a posting
     * @id id of the record to delete
     * @return OK
     */
    postings_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/postings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * process ESR files on server
     * @return OK
     */
    postings_ProcessESR(organisationId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/postings/process/esr/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_ProcessESR(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_ProcessESR(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPostings_ProcessESR(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * export postings
     * @resend (optional) 
     * @return OK
     */
    postings_Export(organisationId: number, startDate: Date, endDate: Date, resend: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/postings/export/{organisationId}?";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (resend !== undefined)
            url_ += "resend=" + encodeURIComponent("" + resend) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processPostings_Export(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostings_Export(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processPostings_Export(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all Resources
     * @organisationId (optional) only get resources owned by this organisation
     * @childrenOnly (optional) only retrieve child (phyiscal) resources
     * @return OK
     */
    resources_GetAll(organisationId: number | null | undefined, childrenOnly: boolean | null | undefined): Observable<ResourceView[]> {
        let url_ = this.baseUrl + "/api/resources?";
        if (organisationId !== undefined)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        if (childrenOnly !== undefined)
            url_ += "childrenOnly=" + encodeURIComponent("" + childrenOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processResources_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResources_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<ResourceView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResourceView[]>><any>Observable.throw(response_);
        });
    }

    protected processResources_GetAll(response: HttpResponseBase): Observable<ResourceView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ResourceView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResourceView[]>(<any>null);
    }

    /**
     * update an Resource
     * @return OK
     */
    resources_Put(updateResourceView: ResourceView): Observable<any> {
        let url_ = this.baseUrl + "/api/resources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateResourceView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processResources_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResources_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processResources_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert an Resource
     * @return OK
     */
    resources_Post(view: ResourceView): Observable<number> {
        let url_ = this.baseUrl + "/api/resources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResources_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResources_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processResources_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * get an Resource by id
     * @return OK
     */
    resources_Get(resourceId: number): Observable<ResourceView> {
        let url_ = this.baseUrl + "/api/resources/{ResourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{ResourceId}", encodeURIComponent("" + resourceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processResources_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResources_Get(<any>response_);
                } catch (e) {
                    return <Observable<ResourceView>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResourceView>><any>Observable.throw(response_);
        });
    }

    protected processResources_Get(response: HttpResponseBase): Observable<ResourceView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResourceView.fromJS(resultData200) : new ResourceView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResourceView>(<any>null);
    }

    /**
     * delete an Resource
     * @id id of the record to delete
     * @return OK
     */
    resources_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/resources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processResources_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResources_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processResources_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * gets all subscribers
     * @subscriptionTypeId (optional) optional: subscription type
     * @organisationId (optional) optional: organisation
     * @expiredNoLongerThanMonths (optional) optional: only subscriptions that have expired no longer than x months ago
     * @return OK
     */
    subscribers_GetSubscribers(subscriptionTypeId: number | null | undefined, organisationId: number | null | undefined, expiredNoLongerThanMonths: number | null | undefined): Observable<SubscribersBySubscriptionView[]> {
        let url_ = this.baseUrl + "/api/subscribers?";
        if (subscriptionTypeId !== undefined)
            url_ += "subscriptionTypeId=" + encodeURIComponent("" + subscriptionTypeId) + "&"; 
        if (organisationId !== undefined)
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        if (expiredNoLongerThanMonths !== undefined)
            url_ += "expiredNoLongerThanMonths=" + encodeURIComponent("" + expiredNoLongerThanMonths) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscribers_GetSubscribers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribers_GetSubscribers(<any>response_);
                } catch (e) {
                    return <Observable<SubscribersBySubscriptionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscribersBySubscriptionView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscribers_GetSubscribers(response: HttpResponseBase): Observable<SubscribersBySubscriptionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribersBySubscriptionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscribersBySubscriptionView[]>(<any>null);
    }

    /**
     * get subscriptions for a subscriber
     * @subscriberId user id of subscriber
     * @return OK
     */
    subscribers_GetSubscriptionsForSubscriber(subscriberId: string): Observable<SubscriptionsBySubscriberView> {
        let url_ = this.baseUrl + "/api/subscribers/subscriber/{subscriberId}";
        if (subscriberId === undefined || subscriberId === null)
            throw new Error("The parameter 'subscriberId' must be defined.");
        url_ = url_.replace("{subscriberId}", encodeURIComponent("" + subscriberId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscribers_GetSubscriptionsForSubscriber(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribers_GetSubscriptionsForSubscriber(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionsBySubscriberView>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionsBySubscriberView>><any>Observable.throw(response_);
        });
    }

    protected processSubscribers_GetSubscriptionsForSubscriber(response: HttpResponseBase): Observable<SubscriptionsBySubscriberView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionsBySubscriberView.fromJS(resultData200) : new SubscriptionsBySubscriberView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionsBySubscriberView>(<any>null);
    }

    /**
     * sychronize users with external mail service
     * @organisationId organisation id
     * @return OK
     */
    subscribers_Synchronize(organisationId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscribers/synchronize/{organisationId}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscribers_Synchronize(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribers_Synchronize(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscribers_Synchronize(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get a  subscription instance by id
     * @subscriptionInstanceId subscription instance
     * @return OK
     */
    subscriptionInstances_Get(subscriptionInstanceId: number): Observable<SubscriptionInstanceView> {
        let url_ = this.baseUrl + "/api/subscription/instances/{subscriptionInstanceId}";
        if (subscriptionInstanceId === undefined || subscriptionInstanceId === null)
            throw new Error("The parameter 'subscriptionInstanceId' must be defined.");
        url_ = url_.replace("{subscriptionInstanceId}", encodeURIComponent("" + subscriptionInstanceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Get(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionInstanceView>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionInstanceView>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Get(response: HttpResponseBase): Observable<SubscriptionInstanceView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionInstanceView.fromJS(resultData200) : new SubscriptionInstanceView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionInstanceView>(<any>null);
    }

    /**
     * get subscription instances for a certain user
     * @organisationId organisation id
     * @eventType only return subscriptions that can book this event type
     * @userId (optional) user id to filter subscriptions by
     * @activeOnly (optional) only return active subscriptions
     * @activePer (optional) active per date (default: current date)
     * @prepaidOnly (optional) only return prepaid subscriptions
     * @return OK
     */
    subscriptionInstances_Query(organisationId: number, eventType: number, userId: string | null | undefined, activeOnly: boolean | null | undefined, activePer: Date | null | undefined, prepaidOnly: boolean | null | undefined): Observable<SubscriptionInstanceView[]> {
        let url_ = this.baseUrl + "/api/subscription/instances/query?";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined and cannot be null.");
        else
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined and cannot be null.");
        else
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (activeOnly !== undefined)
            url_ += "activeOnly=" + encodeURIComponent("" + activeOnly) + "&"; 
        if (activePer !== undefined)
            url_ += "activePer=" + encodeURIComponent(activePer ? "" + activePer.toJSON() : "") + "&"; 
        if (prepaidOnly !== undefined)
            url_ += "prepaidOnly=" + encodeURIComponent("" + prepaidOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Query(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Query(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionInstanceView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionInstanceView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Query(response: HttpResponseBase): Observable<SubscriptionInstanceView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriptionInstanceView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionInstanceView[]>(<any>null);
    }

    /**
     * get existing subscriptions and subscriptiontypes that can be subscribed for certain event type
     * @eventType event type subscriptions can be used to
     * @userId guid of user
     * @organisationId organisation id
     * @return OK
     */
    subscriptionInstances_BookableBy(eventType: number, userId: string, organisationId: number): Observable<SubscriptionInstanceView[]> {
        let url_ = this.baseUrl + "/api/subscription/instances/bookable?";
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined and cannot be null.");
        else
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&"; 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined and cannot be null.");
        else
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_BookableBy(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_BookableBy(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionInstanceView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionInstanceView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_BookableBy(response: HttpResponseBase): Observable<SubscriptionInstanceView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriptionInstanceView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionInstanceView[]>(<any>null);
    }

    /**
     * update an SubscriptionInstance
     * @return OK
     */
    subscriptionInstances_Put(updateSubscriptionInstanceView: SubscriptionInstanceView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateSubscriptionInstanceView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert a subscription instance
     * @return OK
     */
    subscriptionInstances_Post(view: SubscriptionInstanceView): Observable<number> {
        let url_ = this.baseUrl + "/api/subscription/instances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Post(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Post(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * update a subscription posting
     * @return OK
     */
    subscriptionInstances_Put2(updateSubscriptionInstanceView: PostingView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/postings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateSubscriptionInstanceView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Put2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Put2(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Put2(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert a subscription posting
     * @return OK
     */
    subscriptionInstances_PostPosting(view: PostingView): Observable<Posting> {
        let url_ = this.baseUrl + "/api/subscription/instances/postings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_PostPosting(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_PostPosting(<any>response_);
                } catch (e) {
                    return <Observable<Posting>><any>Observable.throw(e);
                }
            } else
                return <Observable<Posting>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_PostPosting(response: HttpResponseBase): Observable<Posting> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Posting.fromJS(resultData200) : new Posting();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Posting>(<any>null);
    }

    /**
     * delete an SubscriptionInstance
     * @id id of the record to delete
     * @return OK
     */
    subscriptionInstances_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get a  subscription instance's postings
     * @subscriptionInstanceId subscription instance
     * @return OK
     */
    subscriptionInstances_GetPostings(subscriptionInstanceId: number): Observable<PostingView[]> {
        let url_ = this.baseUrl + "/api/subscription/instances/{subscriptionInstanceId}/postings";
        if (subscriptionInstanceId === undefined || subscriptionInstanceId === null)
            throw new Error("The parameter 'subscriptionInstanceId' must be defined.");
        url_ = url_.replace("{subscriptionInstanceId}", encodeURIComponent("" + subscriptionInstanceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_GetPostings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_GetPostings(<any>response_);
                } catch (e) {
                    return <Observable<PostingView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostingView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_GetPostings(response: HttpResponseBase): Observable<PostingView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PostingView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostingView[]>(<any>null);
    }

    /**
     * delete a subscription posting
     * @id id of the record to delete
     * @return OK
     */
    subscriptionInstances_DeletePosting(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/postings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_DeletePosting(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_DeletePosting(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_DeletePosting(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * check whether a unit balance from a previous subscription can be brought forward to new subscription.
    if so, close out previous subscription
     * @id id of new subscription instance
     * @return OK
     */
    subscriptionInstances_Balance(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/balance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Balance(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Balance(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Balance(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * check all open subscripions whether a unit balance from a previous subscription can be brought forward to new subscription.
    if so, close out previous subscriptions
     * @return OK
     */
    subscriptionInstances_Balance2(): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/balance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_Balance2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_Balance2(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_Balance2(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get calculations which are visible for an event participant
     * @subscriptionInstanceId id of a subscription instance to query
     * @eventTypeId (optional) event type id - defaults to 1
     * @return OK
     */
    subscriptionInstances_GetCalculations(subscriptionInstanceId: number, eventTypeId: number | null | undefined): Observable<DomainActionView[]> {
        let url_ = this.baseUrl + "/api/subscription/instances/{subscriptionInstanceId}/calculations?";
        if (subscriptionInstanceId === undefined || subscriptionInstanceId === null)
            throw new Error("The parameter 'subscriptionInstanceId' must be defined.");
        url_ = url_.replace("{subscriptionInstanceId}", encodeURIComponent("" + subscriptionInstanceId)); 
        if (eventTypeId !== undefined)
            url_ += "eventTypeId=" + encodeURIComponent("" + eventTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_GetCalculations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_GetCalculations(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_GetCalculations(response: HttpResponseBase): Observable<DomainActionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DomainActionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView[]>(<any>null);
    }

    /**
     * add a payment to subscription
     * @return OK
     */
    subscriptionInstances_AddPayment(view: PaymentView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_AddPayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_AddPayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_AddPayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get manual actions for a subscription instance
     * @subscriptionInstanceId id of a subscription instance to query
     * @return OK
     */
    subscriptionInstances_GetManualActions(subscriptionInstanceId: number): Observable<DomainActionView[]> {
        let url_ = this.baseUrl + "/api/subscription/instances/{subscriptionInstanceId}/actions/manual";
        if (subscriptionInstanceId === undefined || subscriptionInstanceId === null)
            throw new Error("The parameter 'subscriptionInstanceId' must be defined.");
        url_ = url_.replace("{subscriptionInstanceId}", encodeURIComponent("" + subscriptionInstanceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_GetManualActions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_GetManualActions(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_GetManualActions(response: HttpResponseBase): Observable<DomainActionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DomainActionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView[]>(<any>null);
    }

    /**
     * execute an action for a subscriptionInstance
     * @return OK
     */
    subscriptionInstances_ExecuteAction(command: ExecuteActionForSubscription): Observable<any> {
        let url_ = this.baseUrl + "/api/subscription/instances/actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionInstances_ExecuteAction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionInstances_ExecuteAction(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionInstances_ExecuteAction(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all Subscriptions
     * @return OK
     */
    subscriptions_GetAll(): Observable<SubscriptionView[]> {
        let url_ = this.baseUrl + "/api/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_GetAll(response: HttpResponseBase): Observable<SubscriptionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriptionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionView[]>(<any>null);
    }

    /**
     * update a Subscription
     * @return OK
     */
    subscriptions_Put(updateSubscriptionView: SubscriptionView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateSubscriptionView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert a Subscription
     * @return OK
     */
    subscriptions_Post(view: SubscriptionView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_Post(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_Post(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get a Subscription by id
     * @return OK
     */
    subscriptions_Get(subscriptionId: number): Observable<SubscriptionView> {
        let url_ = this.baseUrl + "/api/subscriptions/{SubscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{SubscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_Get(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionView>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionView>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_Get(response: HttpResponseBase): Observable<SubscriptionView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionView.fromJS(resultData200) : new SubscriptionView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionView>(<any>null);
    }

    /**
     * delete a Subscription
     * @id id of the record to delete
     * @return OK
     */
    subscriptions_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * seed subscriptions from an auxiliary system
     * @organisationId id of organisation
     * @start start date
     * @return OK
     */
    subscriptions_Import(organisationId: number, start: Date): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptions/import/{organisationId}/{start}";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        if (start === undefined || start === null)
            throw new Error("The parameter 'start' must be defined.");
        url_ = url_.replace("{start}", encodeURIComponent(start ? "" + start.toJSON() : "null")); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptions_Import(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptions_Import(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions_Import(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all subscription types that meet certain criteria
     * @organisationId (optional) organisation
     * @prepaidOnly (optional) only return prepaid subscriptions
     * @eventType only return types that can book a certain event type
     * @bookableOnly only return types that can be booked by user (self service)
     * @return OK
     */
    subscriptionTypes_Query(organisationId: number, prepaidOnly: boolean, eventType: number, bookableOnly: boolean): Observable<SubscriptionTypeView[]> {
        let url_ = this.baseUrl + "/api/subscriptiontypes/query?";
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined and cannot be null.");
        else
            url_ += "organisationId=" + encodeURIComponent("" + organisationId) + "&"; 
        if (prepaidOnly === undefined || prepaidOnly === null)
            throw new Error("The parameter 'prepaidOnly' must be defined and cannot be null.");
        else
            url_ += "prepaidOnly=" + encodeURIComponent("" + prepaidOnly) + "&"; 
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined and cannot be null.");
        else
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&"; 
        if (bookableOnly === undefined || bookableOnly === null)
            throw new Error("The parameter 'bookableOnly' must be defined and cannot be null.");
        else
            url_ += "bookableOnly=" + encodeURIComponent("" + bookableOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_Query(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_Query(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionTypeView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionTypeView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_Query(response: HttpResponseBase): Observable<SubscriptionTypeView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriptionTypeView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionTypeView[]>(<any>null);
    }

    /**
     * get all Subscription types
     * @return OK
     */
    subscriptionTypes_GetAll(): Observable<SubscriptionTypeView[]> {
        let url_ = this.baseUrl + "/api/subscriptiontypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_GetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionTypeView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionTypeView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_GetAll(response: HttpResponseBase): Observable<SubscriptionTypeView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriptionTypeView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionTypeView[]>(<any>null);
    }

    /**
     * update a SubscriptionType
     * @return OK
     */
    subscriptionTypes_Put(updateSubscriptionTypeView: SubscriptionTypeView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptiontypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateSubscriptionTypeView);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * insert a SubscriptionType
     * @return OK
     */
    subscriptionTypes_Post(view: SubscriptionTypeView): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptiontypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_Post(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_Post(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get a SubscriptionType by id
     * @return OK
     */
    subscriptionTypes_Get(subscriptionTypeId: number): Observable<SubscriptionTypeView> {
        let url_ = this.baseUrl + "/api/subscriptiontypes/{SubscriptionTypeId}";
        if (subscriptionTypeId === undefined || subscriptionTypeId === null)
            throw new Error("The parameter 'subscriptionTypeId' must be defined.");
        url_ = url_.replace("{SubscriptionTypeId}", encodeURIComponent("" + subscriptionTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_Get(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionTypeView>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscriptionTypeView>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_Get(response: HttpResponseBase): Observable<SubscriptionTypeView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionTypeView.fromJS(resultData200) : new SubscriptionTypeView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscriptionTypeView>(<any>null);
    }

    /**
     * delete a SubscriptionType
     * @id id of the record to delete
     * @return OK
     */
    subscriptionTypes_Delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/subscriptiontypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get calculations which are visible for a subscription type and event type
     * @subscriptionTypeId id of a subscription type to query
     * @eventTypeId (optional) event type id
     * @return OK
     */
    subscriptionTypes_GetCalculations(subscriptionTypeId: number, eventTypeId: number | null | undefined): Observable<DomainActionView[]> {
        let url_ = this.baseUrl + "/api/subscriptiontypes/{subscriptionTypeId}/calculations?";
        if (subscriptionTypeId === undefined || subscriptionTypeId === null)
            throw new Error("The parameter 'subscriptionTypeId' must be defined.");
        url_ = url_.replace("{subscriptionTypeId}", encodeURIComponent("" + subscriptionTypeId)); 
        if (eventTypeId !== undefined)
            url_ += "eventTypeId=" + encodeURIComponent("" + eventTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processSubscriptionTypes_GetCalculations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionTypes_GetCalculations(<any>response_);
                } catch (e) {
                    return <Observable<DomainActionView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainActionView[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionTypes_GetCalculations(response: HttpResponseBase): Observable<DomainActionView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DomainActionView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DomainActionView[]>(<any>null);
    }

    /**
     * @return OK
     */
    test_Test(): Observable<string> {
        let url_ = this.baseUrl + "/api/test/culture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processTest_Test(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_Test(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processTest_Test(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string>(<any>null);
    }

    /**
     * @return OK
     */
    test_UpdateEvents(): Observable<any> {
        let url_ = this.baseUrl + "/api/test/updateevents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processTest_UpdateEvents(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_UpdateEvents(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processTest_UpdateEvents(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @return OK
     */
    test_ActivateSubscriptions(): Observable<any> {
        let url_ = this.baseUrl + "/api/test/activatesubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processTest_ActivateSubscriptions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_ActivateSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processTest_ActivateSubscriptions(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @return OK
     */
    test_UpdateDatabase(): Observable<any> {
        let url_ = this.baseUrl + "/api/test/updatedatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processTest_UpdateDatabase(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_UpdateDatabase(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processTest_UpdateDatabase(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get all users or or search a user by name
    requester needs to be member of Superadmin role
     * @userName (optional) 
     * @return OK
     */
    users_Get(userName: string | null | undefined): Observable<UserView[]> {
        let url_ = this.baseUrl + "/api/users?";
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_Get(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_Get(<any>response_);
                } catch (e) {
                    return <Observable<UserView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserView[]>><any>Observable.throw(response_);
        });
    }

    protected processUsers_Get(response: HttpResponseBase): Observable<UserView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserView[]>(<any>null);
    }

    /**
     * update a user
    can be called by administrators for all users or the currently authenticated user for himself
     * @return OK
     */
    users_Put(view: UserView): Observable<any> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_Put(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_Put(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_Put(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * add a user
    this is for admins only
    unauthorized users can be added via the register api
     * @return OK
     */
    users_Post(view: UserView): Observable<any> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_Post(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_Post(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_Post(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * check if a users exists by e-mail address -
    this is used by the forgot-password function
     * @return OK
     */
    users_UserExistsByMail(eMail: string): Observable<any> {
        let url_ = this.baseUrl + "/api/users/mail/exists/{eMail}";
        if (eMail === undefined || eMail === null)
            throw new Error("The parameter 'eMail' must be defined.");
        url_ = url_.replace("{eMail}", encodeURIComponent("" + eMail)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_UserExistsByMail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_UserExistsByMail(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_UserExistsByMail(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * get user by id
     * @return OK
     */
    users_GetById(userId: string): Observable<UserView> {
        let url_ = this.baseUrl + "/api/users/id/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_GetById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_GetById(<any>response_);
                } catch (e) {
                    return <Observable<UserView>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserView>><any>Observable.throw(response_);
        });
    }

    protected processUsers_GetById(response: HttpResponseBase): Observable<UserView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserView.fromJS(resultData200) : new UserView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserView>(<any>null);
    }

    /**
     * get user by username
     * @return OK
     */
    users_GetByUsername(userName: string): Observable<UserView> {
        let url_ = this.baseUrl + "/api/users/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_GetByUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_GetByUsername(<any>response_);
                } catch (e) {
                    return <Observable<UserView>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserView>><any>Observable.throw(response_);
        });
    }

    protected processUsers_GetByUsername(response: HttpResponseBase): Observable<UserView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserView.fromJS(resultData200) : new UserView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserView>(<any>null);
    }

    /**
     * get user by name
     * @return OK
     */
    users_GetByName(name: string): Observable<UserView[]> {
        let url_ = this.baseUrl + "/api/users/name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_GetByName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_GetByName(<any>response_);
                } catch (e) {
                    return <Observable<UserView[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserView[]>><any>Observable.throw(response_);
        });
    }

    protected processUsers_GetByName(response: HttpResponseBase): Observable<UserView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserView.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserView[]>(<any>null);
    }

    /**
     * get the currently authenticated user
     * @return OK
     */
    users_GetCurrentUser(): Observable<UserView> {
        let url_ = this.baseUrl + "/api/users/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_GetCurrentUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_GetCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserView>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserView>><any>Observable.throw(response_);
        });
    }

    protected processUsers_GetCurrentUser(response: HttpResponseBase): Observable<UserView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserView.fromJS(resultData200) : new UserView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserView>(<any>null);
    }

    /**
     * register a user
    this registers a user and sends a confirmation mail to the supplied mail address
    the link to the confirmation url must be supplied in field ConfirmationUrl of the view
     * @return OK
     */
    users_Register(view: UserView): Observable<any> {
        let url_ = this.baseUrl + "/api/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_Register(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_Register(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_Register(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * request a password reset token by mail for a forgotten password
     * @return OK
     */
    users_RequestPasswordChangeToken(view: ResetPasswordView): Observable<any> {
        let url_ = this.baseUrl + "/api/users/password/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_RequestPasswordChangeToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_RequestPasswordChangeToken(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_RequestPasswordChangeToken(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * reset a password for non-authorized user by presenting previously issued token
     * @view ResetPasswordView object, must contain UserId and token
     * @return OK
     */
    users_ResetPasswordUsingToken(view: ResetPasswordView): Observable<any> {
        let url_ = this.baseUrl + "/api/users/password/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(view);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_ResetPasswordUsingToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_ResetPasswordUsingToken(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_ResetPasswordUsingToken(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * delete a user
     * @id id of the user to delete
     * @return OK
     */
    users_Delete(id: string): Observable<any> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processUsers_Delete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUsers_Delete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }
}

export class DomainActionView implements IDomainActionView {
    title?: string | undefined;
    description?: string | undefined;
    type?: DomainActionViewType | undefined;
    command?: string | undefined;
    automatic?: boolean | undefined;
    active?: boolean | undefined;
    showUnits?: boolean | undefined;
    ruleExpression?: string | undefined;
    actionExpression?: string | undefined;
    messageTo?: string | undefined;
    messageFrom?: string | undefined;
    messageCC?: string | undefined;
    messageBcc?: string | undefined;
    messageSubject?: string | undefined;
    messageBody?: string | undefined;
    actionFailedMessage?: string | undefined;
    amount?: number | undefined;
    id?: number | undefined;

    constructor(data?: IDomainActionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.description = data["Description"];
            this.type = data["Type"];
            this.command = data["Command"];
            this.automatic = data["Automatic"];
            this.active = data["Active"];
            this.showUnits = data["ShowUnits"];
            this.ruleExpression = data["RuleExpression"];
            this.actionExpression = data["ActionExpression"];
            this.messageTo = data["MessageTo"];
            this.messageFrom = data["MessageFrom"];
            this.messageCC = data["MessageCC"];
            this.messageBcc = data["MessageBcc"];
            this.messageSubject = data["MessageSubject"];
            this.messageBody = data["MessageBody"];
            this.actionFailedMessage = data["ActionFailedMessage"];
            this.amount = data["Amount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainActionView {
        let result = new DomainActionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["Type"] = this.type;
        data["Command"] = this.command;
        data["Automatic"] = this.automatic;
        data["Active"] = this.active;
        data["ShowUnits"] = this.showUnits;
        data["RuleExpression"] = this.ruleExpression;
        data["ActionExpression"] = this.actionExpression;
        data["MessageTo"] = this.messageTo;
        data["MessageFrom"] = this.messageFrom;
        data["MessageCC"] = this.messageCC;
        data["MessageBcc"] = this.messageBcc;
        data["MessageSubject"] = this.messageSubject;
        data["MessageBody"] = this.messageBody;
        data["ActionFailedMessage"] = this.actionFailedMessage;
        data["Amount"] = this.amount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDomainActionView {
    title?: string | undefined;
    description?: string | undefined;
    type?: DomainActionViewType | undefined;
    command?: string | undefined;
    automatic?: boolean | undefined;
    active?: boolean | undefined;
    showUnits?: boolean | undefined;
    ruleExpression?: string | undefined;
    actionExpression?: string | undefined;
    messageTo?: string | undefined;
    messageFrom?: string | undefined;
    messageCC?: string | undefined;
    messageBcc?: string | undefined;
    messageSubject?: string | undefined;
    messageBody?: string | undefined;
    actionFailedMessage?: string | undefined;
    amount?: number | undefined;
    id?: number | undefined;
}

export class CalendarView implements ICalendarView {
    key?: number | undefined;
    allDay?: boolean | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    startEnd?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    statusId?: CalendarViewStatusId | undefined;
    subject?: string | undefined;
    resourceId?: number | undefined;
    resourceTitle?: string | undefined;
    resourceCost?: number | undefined;
    eventTypeId?: number | undefined;
    eventTypeTitle?: string | undefined;
    subscriptionTypeTitle?: string | undefined;
    public?: boolean | undefined;
    id?: string | undefined;

    constructor(data?: ICalendarView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["Key"];
            this.allDay = data["AllDay"];
            this.description = data["Description"];
            this.start = data["Start"] ? new Date(data["Start"].toString()) : <any>undefined;
            this.end = data["End"] ? new Date(data["End"].toString()) : <any>undefined;
            this.startEnd = data["StartEnd"];
            this.location = data["Location"];
            this.status = data["Status"];
            this.statusId = data["StatusId"];
            this.subject = data["Subject"];
            this.resourceId = data["ResourceId"];
            this.resourceTitle = data["ResourceTitle"];
            this.resourceCost = data["ResourceCost"];
            this.eventTypeId = data["EventTypeId"];
            this.eventTypeTitle = data["EventTypeTitle"];
            this.subscriptionTypeTitle = data["SubscriptionTypeTitle"];
            this.public = data["Public"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CalendarView {
        let result = new CalendarView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["AllDay"] = this.allDay;
        data["Description"] = this.description;
        data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["End"] = this.end ? this.end.toISOString() : <any>undefined;
        data["StartEnd"] = this.startEnd;
        data["Location"] = this.location;
        data["Status"] = this.status;
        data["StatusId"] = this.statusId;
        data["Subject"] = this.subject;
        data["ResourceId"] = this.resourceId;
        data["ResourceTitle"] = this.resourceTitle;
        data["ResourceCost"] = this.resourceCost;
        data["EventTypeId"] = this.eventTypeId;
        data["EventTypeTitle"] = this.eventTypeTitle;
        data["SubscriptionTypeTitle"] = this.subscriptionTypeTitle;
        data["Public"] = this.public;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICalendarView {
    key?: number | undefined;
    allDay?: boolean | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    startEnd?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    statusId?: CalendarViewStatusId | undefined;
    subject?: string | undefined;
    resourceId?: number | undefined;
    resourceTitle?: string | undefined;
    resourceCost?: number | undefined;
    eventTypeId?: number | undefined;
    eventTypeTitle?: string | undefined;
    subscriptionTypeTitle?: string | undefined;
    public?: boolean | undefined;
    id?: string | undefined;
}

export class EventParticipantView implements IEventParticipantView {
    eventId?: string | undefined;
    participantId?: string | undefined;
    participantName?: string | undefined;
    participantFirstName?: string | undefined;
    participantLastName?: string | undefined;
    participantPhoneNumber?: string | undefined;
    participantEmail?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriberName?: string | undefined;
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    eventCost?: number | undefined;
    resourceCost?: number | undefined;
    rebate?: number | undefined;
    costNet?: number | undefined;
    cost?: number | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: number | undefined;

    constructor(data?: IEventParticipantView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventId = data["EventId"];
            this.participantId = data["ParticipantId"];
            this.participantName = data["ParticipantName"];
            this.participantFirstName = data["ParticipantFirstName"];
            this.participantLastName = data["ParticipantLastName"];
            this.participantPhoneNumber = data["ParticipantPhoneNumber"];
            this.participantEmail = data["ParticipantEmail"];
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            this.subscriberName = data["SubscriberName"];
            this.subscriptionTypeId = data["SubscriptionTypeId"];
            this.subscriptionTypeTitle = data["SubscriptionTypeTitle"];
            this.eventCost = data["EventCost"];
            this.resourceCost = data["ResourceCost"];
            this.rebate = data["Rebate"];
            this.costNet = data["CostNet"];
            this.cost = data["Cost"];
            if (data["Actions"] && data["Actions"].constructor === Array) {
                this.actions = [];
                for (let item of data["Actions"])
                    this.actions.push(EventParticipantActionView.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventParticipantView {
        let result = new EventParticipantView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventId"] = this.eventId;
        data["ParticipantId"] = this.participantId;
        data["ParticipantName"] = this.participantName;
        data["ParticipantFirstName"] = this.participantFirstName;
        data["ParticipantLastName"] = this.participantLastName;
        data["ParticipantPhoneNumber"] = this.participantPhoneNumber;
        data["ParticipantEmail"] = this.participantEmail;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["SubscriberName"] = this.subscriberName;
        data["SubscriptionTypeId"] = this.subscriptionTypeId;
        data["SubscriptionTypeTitle"] = this.subscriptionTypeTitle;
        data["EventCost"] = this.eventCost;
        data["ResourceCost"] = this.resourceCost;
        data["Rebate"] = this.rebate;
        data["CostNet"] = this.costNet;
        data["Cost"] = this.cost;
        if (this.actions && this.actions.constructor === Array) {
            data["Actions"] = [];
            for (let item of this.actions)
                data["Actions"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IEventParticipantView {
    eventId?: string | undefined;
    participantId?: string | undefined;
    participantName?: string | undefined;
    participantFirstName?: string | undefined;
    participantLastName?: string | undefined;
    participantPhoneNumber?: string | undefined;
    participantEmail?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriberName?: string | undefined;
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    eventCost?: number | undefined;
    resourceCost?: number | undefined;
    rebate?: number | undefined;
    costNet?: number | undefined;
    cost?: number | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: number | undefined;
}

export class EventParticipantActionView implements IEventParticipantActionView {
    domainActionId?: number | undefined;
    amount?: number | undefined;
    comment?: string | undefined;

    constructor(data?: IEventParticipantActionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainActionId = data["DomainActionId"];
            this.amount = data["Amount"];
            this.comment = data["Comment"];
        }
    }

    static fromJS(data: any): EventParticipantActionView {
        let result = new EventParticipantActionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DomainActionId"] = this.domainActionId;
        data["Amount"] = this.amount;
        data["Comment"] = this.comment;
        return data; 
    }
}

export interface IEventParticipantActionView {
    domainActionId?: number | undefined;
    amount?: number | undefined;
    comment?: string | undefined;
}

export class EventResourceView implements IEventResourceView {
    eventId?: string | undefined;
    resourceId?: number | undefined;
    resourceTitle?: string | undefined;
    organisationTitle?: string | undefined;
    insertedAt?: Date | undefined;
    insertedByUsername?: string | undefined;
    updatedAt?: Date | undefined;
    updatedByUsername?: string | undefined;
    nrResourcesRequested?: number | undefined;
    resourceCost?: number | undefined;
    resourceRebate?: number | undefined;
    resourceCostNet?: number | undefined;
    id?: number | undefined;

    constructor(data?: IEventResourceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventId = data["EventId"];
            this.resourceId = data["ResourceId"];
            this.resourceTitle = data["ResourceTitle"];
            this.organisationTitle = data["OrganisationTitle"];
            this.insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            this.insertedByUsername = data["InsertedByUsername"];
            this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
            this.updatedByUsername = data["UpdatedByUsername"];
            this.nrResourcesRequested = data["NrResourcesRequested"];
            this.resourceCost = data["ResourceCost"];
            this.resourceRebate = data["ResourceRebate"];
            this.resourceCostNet = data["ResourceCostNet"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventResourceView {
        let result = new EventResourceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventId"] = this.eventId;
        data["ResourceId"] = this.resourceId;
        data["ResourceTitle"] = this.resourceTitle;
        data["OrganisationTitle"] = this.organisationTitle;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["InsertedByUsername"] = this.insertedByUsername;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["UpdatedByUsername"] = this.updatedByUsername;
        data["NrResourcesRequested"] = this.nrResourcesRequested;
        data["ResourceCost"] = this.resourceCost;
        data["ResourceRebate"] = this.resourceRebate;
        data["ResourceCostNet"] = this.resourceCostNet;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEventResourceView {
    eventId?: string | undefined;
    resourceId?: number | undefined;
    resourceTitle?: string | undefined;
    organisationTitle?: string | undefined;
    insertedAt?: Date | undefined;
    insertedByUsername?: string | undefined;
    updatedAt?: Date | undefined;
    updatedByUsername?: string | undefined;
    nrResourcesRequested?: number | undefined;
    resourceCost?: number | undefined;
    resourceRebate?: number | undefined;
    resourceCostNet?: number | undefined;
    id?: number | undefined;
}

export class EventView implements IEventView {
    allDay?: boolean | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    readonly startEnd?: string | undefined;
    nrParticipants?: number | undefined;
    type?: number | undefined;
    location?: string | undefined;
    recurrence?: string | undefined;
    status?: number | undefined;
    subject?: string | undefined;
    reminderInfo?: string | undefined;
    resourceCost?: number | undefined;
    resourceIds?: string | undefined;
    eventTypeId?: number | undefined;
    eventTypeTitle?: string | undefined;
    public?: boolean | undefined;
    tarifLevel?: number | undefined;
    participantId?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    participants?: EventEventParticipantView[] | undefined;
    subscriptionTypeId?: number | undefined;
    resourceRequest?: ResourceRequest[] | undefined;
    selectedActions?: string | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: string | undefined;

    constructor(data?: IEventView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allDay = data["AllDay"];
            this.description = data["Description"];
            this.start = data["Start"] ? new Date(data["Start"].toString()) : <any>undefined;
            this.end = data["End"] ? new Date(data["End"].toString()) : <any>undefined;
            (<any>this).startEnd = data["StartEnd"];
            this.nrParticipants = data["NrParticipants"];
            this.type = data["Type"];
            this.location = data["Location"];
            this.recurrence = data["Recurrence"];
            this.status = data["Status"];
            this.subject = data["Subject"];
            this.reminderInfo = data["ReminderInfo"];
            this.resourceCost = data["ResourceCost"];
            this.resourceIds = data["ResourceIds"];
            this.eventTypeId = data["EventTypeId"];
            this.eventTypeTitle = data["EventTypeTitle"];
            this.public = data["Public"];
            this.tarifLevel = data["TarifLevel"];
            this.participantId = data["ParticipantId"];
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            if (data["Participants"] && data["Participants"].constructor === Array) {
                this.participants = [];
                for (let item of data["Participants"])
                    this.participants.push(EventEventParticipantView.fromJS(item));
            }
            this.subscriptionTypeId = data["SubscriptionTypeId"];
            if (data["ResourceRequest"] && data["ResourceRequest"].constructor === Array) {
                this.resourceRequest = [];
                for (let item of data["ResourceRequest"])
                    this.resourceRequest.push(ResourceRequest.fromJS(item));
            }
            this.selectedActions = data["SelectedActions"];
            if (data["Actions"] && data["Actions"].constructor === Array) {
                this.actions = [];
                for (let item of data["Actions"])
                    this.actions.push(EventParticipantActionView.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventView {
        let result = new EventView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AllDay"] = this.allDay;
        data["Description"] = this.description;
        data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["End"] = this.end ? this.end.toISOString() : <any>undefined;
        data["StartEnd"] = this.startEnd;
        data["NrParticipants"] = this.nrParticipants;
        data["Type"] = this.type;
        data["Location"] = this.location;
        data["Recurrence"] = this.recurrence;
        data["Status"] = this.status;
        data["Subject"] = this.subject;
        data["ReminderInfo"] = this.reminderInfo;
        data["ResourceCost"] = this.resourceCost;
        data["ResourceIds"] = this.resourceIds;
        data["EventTypeId"] = this.eventTypeId;
        data["EventTypeTitle"] = this.eventTypeTitle;
        data["Public"] = this.public;
        data["TarifLevel"] = this.tarifLevel;
        data["ParticipantId"] = this.participantId;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        if (this.participants && this.participants.constructor === Array) {
            data["Participants"] = [];
            for (let item of this.participants)
                data["Participants"].push(item.toJSON());
        }
        data["SubscriptionTypeId"] = this.subscriptionTypeId;
        if (this.resourceRequest && this.resourceRequest.constructor === Array) {
            data["ResourceRequest"] = [];
            for (let item of this.resourceRequest)
                data["ResourceRequest"].push(item.toJSON());
        }
        data["SelectedActions"] = this.selectedActions;
        if (this.actions && this.actions.constructor === Array) {
            data["Actions"] = [];
            for (let item of this.actions)
                data["Actions"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IEventView {
    allDay?: boolean | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    startEnd?: string | undefined;
    nrParticipants?: number | undefined;
    type?: number | undefined;
    location?: string | undefined;
    recurrence?: string | undefined;
    status?: number | undefined;
    subject?: string | undefined;
    reminderInfo?: string | undefined;
    resourceCost?: number | undefined;
    resourceIds?: string | undefined;
    eventTypeId?: number | undefined;
    eventTypeTitle?: string | undefined;
    public?: boolean | undefined;
    tarifLevel?: number | undefined;
    participantId?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    participants?: EventEventParticipantView[] | undefined;
    subscriptionTypeId?: number | undefined;
    resourceRequest?: ResourceRequest[] | undefined;
    selectedActions?: string | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: string | undefined;
}

export class EventEventParticipantView implements IEventEventParticipantView {
    participantId?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriptionTypeId?: number | undefined;
    cost?: number | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: number | undefined;

    constructor(data?: IEventEventParticipantView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.participantId = data["ParticipantId"];
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            this.subscriptionTypeId = data["SubscriptionTypeId"];
            this.cost = data["Cost"];
            if (data["Actions"] && data["Actions"].constructor === Array) {
                this.actions = [];
                for (let item of data["Actions"])
                    this.actions.push(EventParticipantActionView.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventEventParticipantView {
        let result = new EventEventParticipantView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ParticipantId"] = this.participantId;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["SubscriptionTypeId"] = this.subscriptionTypeId;
        data["Cost"] = this.cost;
        if (this.actions && this.actions.constructor === Array) {
            data["Actions"] = [];
            for (let item of this.actions)
                data["Actions"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IEventEventParticipantView {
    participantId?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriptionTypeId?: number | undefined;
    cost?: number | undefined;
    actions?: EventParticipantActionView[] | undefined;
    id?: number | undefined;
}

export class ResourceRequest implements IResourceRequest {
    resourceId?: number | undefined;
    nrRequested?: number | undefined;
    start?: Date | undefined;
    end?: Date | undefined;

    constructor(data?: IResourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resourceId = data["ResourceId"];
            this.nrRequested = data["NrRequested"];
            this.start = data["Start"] ? new Date(data["Start"].toString()) : <any>undefined;
            this.end = data["End"] ? new Date(data["End"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResourceRequest {
        let result = new ResourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResourceId"] = this.resourceId;
        data["NrRequested"] = this.nrRequested;
        data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["End"] = this.end ? this.end.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResourceRequest {
    resourceId?: number | undefined;
    nrRequested?: number | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
}

export class EventTypeView implements IEventTypeView {
    title?: string | undefined;
    maxParticipants?: number | undefined;
    minParticipants?: number | undefined;
    priceCalculationType?: EventTypeViewPriceCalculationType | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    color?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    cancellationTerms?: string | undefined;
    id?: number | undefined;

    constructor(data?: IEventTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.maxParticipants = data["MaxParticipants"];
            this.minParticipants = data["MinParticipants"];
            this.priceCalculationType = data["PriceCalculationType"];
            this.organisationId = data["OrganisationId"];
            this.organisationTitle = data["OrganisationTitle"];
            this.color = data["Color"];
            this.ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            this.cancellationTerms = data["CancellationTerms"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventTypeView {
        let result = new EventTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["MaxParticipants"] = this.maxParticipants;
        data["MinParticipants"] = this.minParticipants;
        data["PriceCalculationType"] = this.priceCalculationType;
        data["OrganisationId"] = this.organisationId;
        data["OrganisationTitle"] = this.organisationTitle;
        data["Color"] = this.color;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["CancellationTerms"] = this.cancellationTerms;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEventTypeView {
    title?: string | undefined;
    maxParticipants?: number | undefined;
    minParticipants?: number | undefined;
    priceCalculationType?: EventTypeViewPriceCalculationType | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    color?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    cancellationTerms?: string | undefined;
    id?: number | undefined;
}

export class OrganisationView implements IOrganisationView {
    title?: string | undefined;
    shortName?: string | undefined;
    organisationTypeId?: number | undefined;
    organisationTypeTitle?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    mailHeader?: string | undefined;
    mailFooter?: string | undefined;
    mailFrom?: string | undefined;
    ledgerPath?: string | undefined;
    vATNo?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    eSRAccountNoPrint?: string | undefined;
    eSRAccountNo?: string | undefined;
    eSRBankRef?: string | undefined;
    eSRFilePath?: string | undefined;
    ledgerAccountNoCommon?: string | undefined;
    bannerFile?: string | undefined;
    bannerDirectory?: string | undefined;
    id?: number | undefined;

    constructor(data?: IOrganisationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.shortName = data["ShortName"];
            this.organisationTypeId = data["OrganisationTypeId"];
            this.organisationTypeTitle = data["OrganisationTypeTitle"];
            this.addressLine1 = data["AddressLine1"];
            this.addressLine2 = data["AddressLine2"];
            this.addressLine3 = data["AddressLine3"];
            this.addressLine4 = data["AddressLine4"];
            this.mailHeader = data["MailHeader"];
            this.mailFooter = data["MailFooter"];
            this.mailFrom = data["MailFrom"];
            this.ledgerPath = data["LedgerPath"];
            this.vATNo = data["VATNo"];
            this.ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            this.eSRAccountNoPrint = data["ESRAccountNoPrint"];
            this.eSRAccountNo = data["ESRAccountNo"];
            this.eSRBankRef = data["ESRBankRef"];
            this.eSRFilePath = data["ESRFilePath"];
            this.ledgerAccountNoCommon = data["LedgerAccountNoCommon"];
            this.bannerFile = data["BannerFile"];
            this.bannerDirectory = data["BannerDirectory"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganisationView {
        let result = new OrganisationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["ShortName"] = this.shortName;
        data["OrganisationTypeId"] = this.organisationTypeId;
        data["OrganisationTypeTitle"] = this.organisationTypeTitle;
        data["AddressLine1"] = this.addressLine1;
        data["AddressLine2"] = this.addressLine2;
        data["AddressLine3"] = this.addressLine3;
        data["AddressLine4"] = this.addressLine4;
        data["MailHeader"] = this.mailHeader;
        data["MailFooter"] = this.mailFooter;
        data["MailFrom"] = this.mailFrom;
        data["LedgerPath"] = this.ledgerPath;
        data["VATNo"] = this.vATNo;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["ESRAccountNoPrint"] = this.eSRAccountNoPrint;
        data["ESRAccountNo"] = this.eSRAccountNo;
        data["ESRBankRef"] = this.eSRBankRef;
        data["ESRFilePath"] = this.eSRFilePath;
        data["LedgerAccountNoCommon"] = this.ledgerAccountNoCommon;
        data["BannerFile"] = this.bannerFile;
        data["BannerDirectory"] = this.bannerDirectory;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganisationView {
    title?: string | undefined;
    shortName?: string | undefined;
    organisationTypeId?: number | undefined;
    organisationTypeTitle?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    mailHeader?: string | undefined;
    mailFooter?: string | undefined;
    mailFrom?: string | undefined;
    ledgerPath?: string | undefined;
    vATNo?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    eSRAccountNoPrint?: string | undefined;
    eSRAccountNo?: string | undefined;
    eSRBankRef?: string | undefined;
    eSRFilePath?: string | undefined;
    ledgerAccountNoCommon?: string | undefined;
    bannerFile?: string | undefined;
    bannerDirectory?: string | undefined;
    id?: number | undefined;
}

export class OrganisationTypeView implements IOrganisationTypeView {
    title?: string | undefined;
    id?: number | undefined;

    constructor(data?: IOrganisationTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganisationTypeView {
        let result = new OrganisationTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganisationTypeView {
    title?: string | undefined;
    id?: number | undefined;
}

export class PaymentGatewayView implements IPaymentGatewayView {
    title?: string | undefined;
    description?: string | undefined;
    instructions?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    initiationUrl?: string | undefined;
    localSuccessUrl?: string | undefined;
    localFailureUrl?: string | undefined;
    buttonImageUrl?: string | undefined;
    active?: boolean | undefined;
    id?: number | undefined;

    constructor(data?: IPaymentGatewayView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.description = data["Description"];
            this.instructions = data["Instructions"];
            this.ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            this.initiationUrl = data["InitiationUrl"];
            this.localSuccessUrl = data["LocalSuccessUrl"];
            this.localFailureUrl = data["LocalFailureUrl"];
            this.buttonImageUrl = data["ButtonImageUrl"];
            this.active = data["Active"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentGatewayView {
        let result = new PaymentGatewayView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["Instructions"] = this.instructions;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["InitiationUrl"] = this.initiationUrl;
        data["LocalSuccessUrl"] = this.localSuccessUrl;
        data["LocalFailureUrl"] = this.localFailureUrl;
        data["ButtonImageUrl"] = this.buttonImageUrl;
        data["Active"] = this.active;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentGatewayView {
    title?: string | undefined;
    description?: string | undefined;
    instructions?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    initiationUrl?: string | undefined;
    localSuccessUrl?: string | undefined;
    localFailureUrl?: string | undefined;
    buttonImageUrl?: string | undefined;
    active?: boolean | undefined;
    id?: number | undefined;
}

export class PostingView implements IPostingView {
    organisationId?: number | undefined;
    subscriptionInstanceId?: number | undefined;
    paymentGatewayId?: number | undefined;
    paymentReference?: string | undefined;
    postingDate?: Date | undefined;
    valueDate?: Date | undefined;
    text?: string | undefined;
    amount?: number | undefined;
    units?: number | undefined;
    ledgerAccountNoDebit?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    ledgerPostedAt?: Date | undefined;
    ledgerBlgNr?: string | undefined;
    ledgerOPNr?: string | undefined;
    id?: number | undefined;

    constructor(data?: IPostingView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organisationId = data["OrganisationId"];
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            this.paymentGatewayId = data["PaymentGatewayId"];
            this.paymentReference = data["PaymentReference"];
            this.postingDate = data["PostingDate"] ? new Date(data["PostingDate"].toString()) : <any>undefined;
            this.valueDate = data["ValueDate"] ? new Date(data["ValueDate"].toString()) : <any>undefined;
            this.text = data["Text"];
            this.amount = data["Amount"];
            this.units = data["Units"];
            this.ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            this.ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            this.ledgerPostedAt = data["LedgerPostedAt"] ? new Date(data["LedgerPostedAt"].toString()) : <any>undefined;
            this.ledgerBlgNr = data["LedgerBlgNr"];
            this.ledgerOPNr = data["LedgerOPNr"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PostingView {
        let result = new PostingView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrganisationId"] = this.organisationId;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["PaymentGatewayId"] = this.paymentGatewayId;
        data["PaymentReference"] = this.paymentReference;
        data["PostingDate"] = this.postingDate ? this.postingDate.toISOString() : <any>undefined;
        data["ValueDate"] = this.valueDate ? this.valueDate.toISOString() : <any>undefined;
        data["Text"] = this.text;
        data["Amount"] = this.amount;
        data["Units"] = this.units;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["LedgerPostedAt"] = this.ledgerPostedAt ? this.ledgerPostedAt.toISOString() : <any>undefined;
        data["LedgerBlgNr"] = this.ledgerBlgNr;
        data["LedgerOPNr"] = this.ledgerOPNr;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPostingView {
    organisationId?: number | undefined;
    subscriptionInstanceId?: number | undefined;
    paymentGatewayId?: number | undefined;
    paymentReference?: string | undefined;
    postingDate?: Date | undefined;
    valueDate?: Date | undefined;
    text?: string | undefined;
    amount?: number | undefined;
    units?: number | undefined;
    ledgerAccountNoDebit?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    ledgerPostedAt?: Date | undefined;
    ledgerBlgNr?: string | undefined;
    ledgerOPNr?: string | undefined;
    id?: number | undefined;
}

export class ResourceView implements IResourceView {
    title?: string | undefined;
    image?: string | undefined;
    color?: string | undefined;
    parentId?: number | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    allocationStrategy?: ResourceViewAllocationStrategy | undefined;
    allocationPriority?: number | undefined;
    needFreeEvent?: boolean | undefined;
    personId?: string | undefined;
    personName?: string | undefined;
    kNXGroupId?: string | undefined;
    kNXDelayBeforeStart?: string | undefined;
    kNXDelayAfterEnd?: string | undefined;
    displayHostName?: string | undefined;
    displayMacAddress?: string | undefined;
    bannerFile?: string | undefined;
    organisationBannerDirectory?: string | undefined;
    organisationBannerFile?: string | undefined;
    id?: number | undefined;

    constructor(data?: IResourceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.image = data["Image"];
            this.color = data["Color"];
            this.parentId = data["ParentId"];
            this.organisationId = data["OrganisationId"];
            this.organisationTitle = data["OrganisationTitle"];
            this.allocationStrategy = data["AllocationStrategy"];
            this.allocationPriority = data["AllocationPriority"];
            this.needFreeEvent = data["NeedFreeEvent"];
            this.personId = data["PersonId"];
            this.personName = data["PersonName"];
            this.kNXGroupId = data["KNXGroupId"];
            this.kNXDelayBeforeStart = data["KNXDelayBeforeStart"];
            this.kNXDelayAfterEnd = data["KNXDelayAfterEnd"];
            this.displayHostName = data["DisplayHostName"];
            this.displayMacAddress = data["DisplayMacAddress"];
            this.bannerFile = data["BannerFile"];
            this.organisationBannerDirectory = data["OrganisationBannerDirectory"];
            this.organisationBannerFile = data["OrganisationBannerFile"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ResourceView {
        let result = new ResourceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["Image"] = this.image;
        data["Color"] = this.color;
        data["ParentId"] = this.parentId;
        data["OrganisationId"] = this.organisationId;
        data["OrganisationTitle"] = this.organisationTitle;
        data["AllocationStrategy"] = this.allocationStrategy;
        data["AllocationPriority"] = this.allocationPriority;
        data["NeedFreeEvent"] = this.needFreeEvent;
        data["PersonId"] = this.personId;
        data["PersonName"] = this.personName;
        data["KNXGroupId"] = this.kNXGroupId;
        data["KNXDelayBeforeStart"] = this.kNXDelayBeforeStart;
        data["KNXDelayAfterEnd"] = this.kNXDelayAfterEnd;
        data["DisplayHostName"] = this.displayHostName;
        data["DisplayMacAddress"] = this.displayMacAddress;
        data["BannerFile"] = this.bannerFile;
        data["OrganisationBannerDirectory"] = this.organisationBannerDirectory;
        data["OrganisationBannerFile"] = this.organisationBannerFile;
        data["id"] = this.id;
        return data; 
    }
}

export interface IResourceView {
    title?: string | undefined;
    image?: string | undefined;
    color?: string | undefined;
    parentId?: number | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    allocationStrategy?: ResourceViewAllocationStrategy | undefined;
    allocationPriority?: number | undefined;
    needFreeEvent?: boolean | undefined;
    personId?: string | undefined;
    personName?: string | undefined;
    kNXGroupId?: string | undefined;
    kNXDelayBeforeStart?: string | undefined;
    kNXDelayAfterEnd?: string | undefined;
    displayHostName?: string | undefined;
    displayMacAddress?: string | undefined;
    bannerFile?: string | undefined;
    organisationBannerDirectory?: string | undefined;
    organisationBannerFile?: string | undefined;
    id?: number | undefined;
}

export class SubscribersBySubscriptionView implements ISubscribersBySubscriptionView {
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    organisationID?: number | undefined;
    organisationTitle?: string | undefined;
    subscriberId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    lastActivityDate?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    birthdate?: Date | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    email?: string | undefined;
    lastExpiryDate?: Date | undefined;
    instanceCount?: number | undefined;
    id?: number | undefined;

    constructor(data?: ISubscribersBySubscriptionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionTypeId = data["SubscriptionTypeId"];
            this.subscriptionTypeTitle = data["SubscriptionTypeTitle"];
            this.organisationID = data["OrganisationID"];
            this.organisationTitle = data["OrganisationTitle"];
            this.subscriberId = data["SubscriberId"];
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.lastActivityDate = data["LastActivityDate"] ? new Date(data["LastActivityDate"].toString()) : <any>undefined;
            this.address = data["Address"];
            this.city = data["City"];
            this.postalCode = data["PostalCode"];
            this.birthdate = data["Birthdate"] ? new Date(data["Birthdate"].toString()) : <any>undefined;
            this.junior = data["Junior"];
            this.student = data["Student"];
            this.email = data["Email"];
            this.lastExpiryDate = data["LastExpiryDate"] ? new Date(data["LastExpiryDate"].toString()) : <any>undefined;
            this.instanceCount = data["InstanceCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscribersBySubscriptionView {
        let result = new SubscribersBySubscriptionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SubscriptionTypeId"] = this.subscriptionTypeId;
        data["SubscriptionTypeTitle"] = this.subscriptionTypeTitle;
        data["OrganisationID"] = this.organisationID;
        data["OrganisationTitle"] = this.organisationTitle;
        data["SubscriberId"] = this.subscriberId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["LastActivityDate"] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
        data["Address"] = this.address;
        data["City"] = this.city;
        data["PostalCode"] = this.postalCode;
        data["Birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["Junior"] = this.junior;
        data["Student"] = this.student;
        data["Email"] = this.email;
        data["LastExpiryDate"] = this.lastExpiryDate ? this.lastExpiryDate.toISOString() : <any>undefined;
        data["InstanceCount"] = this.instanceCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscribersBySubscriptionView {
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    organisationID?: number | undefined;
    organisationTitle?: string | undefined;
    subscriberId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    lastActivityDate?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    birthdate?: Date | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    email?: string | undefined;
    lastExpiryDate?: Date | undefined;
    instanceCount?: number | undefined;
    id?: number | undefined;
}

export class SubscriptionsBySubscriberView implements ISubscriptionsBySubscriberView {
    subscriberId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    lastActivityDate?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    birthdate?: Date | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    email?: string | undefined;
    lastExpiryDate?: Date | undefined;
    instanceCount?: number | undefined;
    subscriptionTitles?: string[] | undefined;
    id?: number | undefined;

    constructor(data?: ISubscriptionsBySubscriberView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriberId = data["SubscriberId"];
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.lastActivityDate = data["LastActivityDate"] ? new Date(data["LastActivityDate"].toString()) : <any>undefined;
            this.address = data["Address"];
            this.city = data["City"];
            this.postalCode = data["PostalCode"];
            this.birthdate = data["Birthdate"] ? new Date(data["Birthdate"].toString()) : <any>undefined;
            this.junior = data["Junior"];
            this.student = data["Student"];
            this.email = data["Email"];
            this.lastExpiryDate = data["LastExpiryDate"] ? new Date(data["LastExpiryDate"].toString()) : <any>undefined;
            this.instanceCount = data["InstanceCount"];
            if (data["SubscriptionTitles"] && data["SubscriptionTitles"].constructor === Array) {
                this.subscriptionTitles = [];
                for (let item of data["SubscriptionTitles"])
                    this.subscriptionTitles.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionsBySubscriberView {
        let result = new SubscriptionsBySubscriberView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SubscriberId"] = this.subscriberId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["LastActivityDate"] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
        data["Address"] = this.address;
        data["City"] = this.city;
        data["PostalCode"] = this.postalCode;
        data["Birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["Junior"] = this.junior;
        data["Student"] = this.student;
        data["Email"] = this.email;
        data["LastExpiryDate"] = this.lastExpiryDate ? this.lastExpiryDate.toISOString() : <any>undefined;
        data["InstanceCount"] = this.instanceCount;
        if (this.subscriptionTitles && this.subscriptionTitles.constructor === Array) {
            data["SubscriptionTitles"] = [];
            for (let item of this.subscriptionTitles)
                data["SubscriptionTitles"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionsBySubscriberView {
    subscriberId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    lastActivityDate?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    birthdate?: Date | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    email?: string | undefined;
    lastExpiryDate?: Date | undefined;
    instanceCount?: number | undefined;
    subscriptionTitles?: string[] | undefined;
    id?: number | undefined;
}

export class SubscriptionInstanceView implements ISubscriptionInstanceView {
    readonly text?: string | undefined;
    subscriptionId?: number | undefined;
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    subscriptionTypeDescription?: string | undefined;
    active?: boolean | undefined;
    subscriptionTypeOrganisationId?: number | undefined;
    subscriptionTypeOrganisationTitle?: string | undefined;
    subscriptionTypeOrganisationAddressPrintableHTML?: string | undefined;
    subscriptionTypeOrganisationBannerFile?: string | undefined;
    subscriptionTypeOrganisationESRAccountNoPrint?: string | undefined;
    subscriptionTypeUnits?: SubscriptionInstanceViewSubscriptionTypeUnits | undefined;
    subscriptionTypePrepaid?: boolean | undefined;
    subscriptionSubscriberId?: string | undefined;
    subscriptionSubscriberIntId?: number | undefined;
    subscriptionSubscriberName?: string | undefined;
    subscriptionSubscriberFirstName?: string | undefined;
    subscriptionSubscriberLastName?: string | undefined;
    subscriptionSubscriberStudent?: string | undefined;
    subscriptionSubscriberJunior?: string | undefined;
    subscriptionSubscriberEmail?: string | undefined;
    subscriptionSubscriberAddressPrintableHTML?: string | undefined;
    cost?: number | undefined;
    rebate?: number | undefined;
    costNet?: number | undefined;
    subscriptionTypeAllowBookingsByUser?: boolean | undefined;
    startDate?: Date | undefined;
    expiryDate?: Date | undefined;
    confirmedDate?: Date | undefined;
    readonly startEnd?: string | undefined;
    postingsBalance?: number | undefined;
    postingsBalanced?: boolean | undefined;
    unitsBalance?: number | undefined;
    unitsStartBalance?: number | undefined;
    unitsBalanceBelowThreshold?: boolean | undefined;
    unitsBalanceTextHTML?: string | undefined;
    eSRCodingLine?: string | undefined;
    id?: number | undefined;

    constructor(data?: ISubscriptionInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).text = data["text"];
            this.subscriptionId = data["SubscriptionId"];
            this.subscriptionTypeId = data["SubscriptionTypeId"];
            this.subscriptionTypeTitle = data["SubscriptionTypeTitle"];
            this.subscriptionTypeDescription = data["SubscriptionTypeDescription"];
            this.active = data["Active"];
            this.subscriptionTypeOrganisationId = data["SubscriptionTypeOrganisationId"];
            this.subscriptionTypeOrganisationTitle = data["SubscriptionTypeOrganisationTitle"];
            this.subscriptionTypeOrganisationAddressPrintableHTML = data["SubscriptionTypeOrganisationAddressPrintableHTML"];
            this.subscriptionTypeOrganisationBannerFile = data["SubscriptionTypeOrganisationBannerFile"];
            this.subscriptionTypeOrganisationESRAccountNoPrint = data["SubscriptionTypeOrganisationESRAccountNoPrint"];
            this.subscriptionTypeUnits = data["SubscriptionTypeUnits"];
            this.subscriptionTypePrepaid = data["SubscriptionTypePrepaid"];
            this.subscriptionSubscriberId = data["SubscriptionSubscriberId"];
            this.subscriptionSubscriberIntId = data["SubscriptionSubscriberIntId"];
            this.subscriptionSubscriberName = data["SubscriptionSubscriberName"];
            this.subscriptionSubscriberFirstName = data["SubscriptionSubscriberFirstName"];
            this.subscriptionSubscriberLastName = data["SubscriptionSubscriberLastName"];
            this.subscriptionSubscriberStudent = data["SubscriptionSubscriberStudent"];
            this.subscriptionSubscriberJunior = data["SubscriptionSubscriberJunior"];
            this.subscriptionSubscriberEmail = data["SubscriptionSubscriberEmail"];
            this.subscriptionSubscriberAddressPrintableHTML = data["SubscriptionSubscriberAddressPrintableHTML"];
            this.cost = data["Cost"];
            this.rebate = data["Rebate"];
            this.costNet = data["CostNet"];
            this.subscriptionTypeAllowBookingsByUser = data["SubscriptionTypeAllowBookingsByUser"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            this.expiryDate = data["ExpiryDate"] ? new Date(data["ExpiryDate"].toString()) : <any>undefined;
            this.confirmedDate = data["ConfirmedDate"] ? new Date(data["ConfirmedDate"].toString()) : <any>undefined;
            (<any>this).startEnd = data["StartEnd"];
            this.postingsBalance = data["PostingsBalance"];
            this.postingsBalanced = data["PostingsBalanced"];
            this.unitsBalance = data["UnitsBalance"];
            this.unitsStartBalance = data["UnitsStartBalance"];
            this.unitsBalanceBelowThreshold = data["UnitsBalanceBelowThreshold"];
            this.unitsBalanceTextHTML = data["UnitsBalanceTextHTML"];
            this.eSRCodingLine = data["ESRCodingLine"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionInstanceView {
        let result = new SubscriptionInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["SubscriptionId"] = this.subscriptionId;
        data["SubscriptionTypeId"] = this.subscriptionTypeId;
        data["SubscriptionTypeTitle"] = this.subscriptionTypeTitle;
        data["SubscriptionTypeDescription"] = this.subscriptionTypeDescription;
        data["Active"] = this.active;
        data["SubscriptionTypeOrganisationId"] = this.subscriptionTypeOrganisationId;
        data["SubscriptionTypeOrganisationTitle"] = this.subscriptionTypeOrganisationTitle;
        data["SubscriptionTypeOrganisationAddressPrintableHTML"] = this.subscriptionTypeOrganisationAddressPrintableHTML;
        data["SubscriptionTypeOrganisationBannerFile"] = this.subscriptionTypeOrganisationBannerFile;
        data["SubscriptionTypeOrganisationESRAccountNoPrint"] = this.subscriptionTypeOrganisationESRAccountNoPrint;
        data["SubscriptionTypeUnits"] = this.subscriptionTypeUnits;
        data["SubscriptionTypePrepaid"] = this.subscriptionTypePrepaid;
        data["SubscriptionSubscriberId"] = this.subscriptionSubscriberId;
        data["SubscriptionSubscriberIntId"] = this.subscriptionSubscriberIntId;
        data["SubscriptionSubscriberName"] = this.subscriptionSubscriberName;
        data["SubscriptionSubscriberFirstName"] = this.subscriptionSubscriberFirstName;
        data["SubscriptionSubscriberLastName"] = this.subscriptionSubscriberLastName;
        data["SubscriptionSubscriberStudent"] = this.subscriptionSubscriberStudent;
        data["SubscriptionSubscriberJunior"] = this.subscriptionSubscriberJunior;
        data["SubscriptionSubscriberEmail"] = this.subscriptionSubscriberEmail;
        data["SubscriptionSubscriberAddressPrintableHTML"] = this.subscriptionSubscriberAddressPrintableHTML;
        data["Cost"] = this.cost;
        data["Rebate"] = this.rebate;
        data["CostNet"] = this.costNet;
        data["SubscriptionTypeAllowBookingsByUser"] = this.subscriptionTypeAllowBookingsByUser;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ExpiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["ConfirmedDate"] = this.confirmedDate ? this.confirmedDate.toISOString() : <any>undefined;
        data["StartEnd"] = this.startEnd;
        data["PostingsBalance"] = this.postingsBalance;
        data["PostingsBalanced"] = this.postingsBalanced;
        data["UnitsBalance"] = this.unitsBalance;
        data["UnitsStartBalance"] = this.unitsStartBalance;
        data["UnitsBalanceBelowThreshold"] = this.unitsBalanceBelowThreshold;
        data["UnitsBalanceTextHTML"] = this.unitsBalanceTextHTML;
        data["ESRCodingLine"] = this.eSRCodingLine;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionInstanceView {
    text?: string | undefined;
    subscriptionId?: number | undefined;
    subscriptionTypeId?: number | undefined;
    subscriptionTypeTitle?: string | undefined;
    subscriptionTypeDescription?: string | undefined;
    active?: boolean | undefined;
    subscriptionTypeOrganisationId?: number | undefined;
    subscriptionTypeOrganisationTitle?: string | undefined;
    subscriptionTypeOrganisationAddressPrintableHTML?: string | undefined;
    subscriptionTypeOrganisationBannerFile?: string | undefined;
    subscriptionTypeOrganisationESRAccountNoPrint?: string | undefined;
    subscriptionTypeUnits?: SubscriptionInstanceViewSubscriptionTypeUnits | undefined;
    subscriptionTypePrepaid?: boolean | undefined;
    subscriptionSubscriberId?: string | undefined;
    subscriptionSubscriberIntId?: number | undefined;
    subscriptionSubscriberName?: string | undefined;
    subscriptionSubscriberFirstName?: string | undefined;
    subscriptionSubscriberLastName?: string | undefined;
    subscriptionSubscriberStudent?: string | undefined;
    subscriptionSubscriberJunior?: string | undefined;
    subscriptionSubscriberEmail?: string | undefined;
    subscriptionSubscriberAddressPrintableHTML?: string | undefined;
    cost?: number | undefined;
    rebate?: number | undefined;
    costNet?: number | undefined;
    subscriptionTypeAllowBookingsByUser?: boolean | undefined;
    startDate?: Date | undefined;
    expiryDate?: Date | undefined;
    confirmedDate?: Date | undefined;
    startEnd?: string | undefined;
    postingsBalance?: number | undefined;
    postingsBalanced?: boolean | undefined;
    unitsBalance?: number | undefined;
    unitsStartBalance?: number | undefined;
    unitsBalanceBelowThreshold?: boolean | undefined;
    unitsBalanceTextHTML?: string | undefined;
    eSRCodingLine?: string | undefined;
    id?: number | undefined;
}

export class Posting implements IPosting {
    readonly organisationId?: number | undefined;
    readonly organisation?: Organisation | undefined;
    readonly eventId?: string | undefined;
    readonly event?: Event | undefined;
    readonly resourceId?: number | undefined;
    readonly resource?: Resource | undefined;
    readonly subscriptionInstanceId?: number | undefined;
    readonly subscriptionInstance?: SubscriptionInstance | undefined;
    readonly eventParticipantId?: number | undefined;
    readonly eventParticipant?: EventParticipant | undefined;
    readonly paymentGatewayId?: number | undefined;
    readonly paymentGateway?: PaymentGateway | undefined;
    readonly actionId?: number | undefined;
    readonly action?: DomainAction | undefined;
    readonly postingDate?: Date | undefined;
    readonly valueDate?: Date | undefined;
    readonly text?: string | undefined;
    readonly amount?: number | undefined;
    readonly units?: number | undefined;
    readonly ledgerAccountNoDebit?: string | undefined;
    readonly ledgerAccountNoCredit?: string | undefined;
    readonly ledgerPostedAt?: Date | undefined;
    readonly ledgerBlgNr?: string | undefined;
    readonly ledgerOPNr?: string | undefined;
    readonly paymentReference?: string | undefined;
    posted?: boolean | undefined;
    readonly reversedAt?: Date | undefined;
    readonly reversedById?: string | undefined;
    readonly reversedBy?: User | undefined;
    reversed?: boolean | undefined;
    readonly isReversal?: boolean | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IPosting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).organisationId = data["OrganisationId"];
            (<any>this).organisation = data["Organisation"] ? Organisation.fromJS(data["Organisation"]) : <any>undefined;
            (<any>this).eventId = data["EventId"];
            (<any>this).event = data["Event"] ? Event.fromJS(data["Event"]) : <any>undefined;
            (<any>this).resourceId = data["ResourceId"];
            (<any>this).resource = data["Resource"] ? Resource.fromJS(data["Resource"]) : <any>undefined;
            (<any>this).subscriptionInstanceId = data["SubscriptionInstanceId"];
            (<any>this).subscriptionInstance = data["SubscriptionInstance"] ? SubscriptionInstance.fromJS(data["SubscriptionInstance"]) : <any>undefined;
            (<any>this).eventParticipantId = data["EventParticipantId"];
            (<any>this).eventParticipant = data["EventParticipant"] ? EventParticipant.fromJS(data["EventParticipant"]) : <any>undefined;
            (<any>this).paymentGatewayId = data["PaymentGatewayId"];
            (<any>this).paymentGateway = data["PaymentGateway"] ? PaymentGateway.fromJS(data["PaymentGateway"]) : <any>undefined;
            (<any>this).actionId = data["ActionId"];
            (<any>this).action = data["Action"] ? DomainAction.fromJS(data["Action"]) : <any>undefined;
            (<any>this).postingDate = data["PostingDate"] ? new Date(data["PostingDate"].toString()) : <any>undefined;
            (<any>this).valueDate = data["ValueDate"] ? new Date(data["ValueDate"].toString()) : <any>undefined;
            (<any>this).text = data["Text"];
            (<any>this).amount = data["Amount"];
            (<any>this).units = data["Units"];
            (<any>this).ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            (<any>this).ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            (<any>this).ledgerPostedAt = data["LedgerPostedAt"] ? new Date(data["LedgerPostedAt"].toString()) : <any>undefined;
            (<any>this).ledgerBlgNr = data["LedgerBlgNr"];
            (<any>this).ledgerOPNr = data["LedgerOPNr"];
            (<any>this).paymentReference = data["PaymentReference"];
            this.posted = data["Posted"];
            (<any>this).reversedAt = data["ReversedAt"] ? new Date(data["ReversedAt"].toString()) : <any>undefined;
            (<any>this).reversedById = data["ReversedById"];
            (<any>this).reversedBy = data["ReversedBy"] ? User.fromJS(data["ReversedBy"]) : <any>undefined;
            this.reversed = data["Reversed"];
            (<any>this).isReversal = data["IsReversal"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Posting {
        let result = new Posting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrganisationId"] = this.organisationId;
        data["Organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["EventId"] = this.eventId;
        data["Event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["ResourceId"] = this.resourceId;
        data["Resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["SubscriptionInstance"] = this.subscriptionInstance ? this.subscriptionInstance.toJSON() : <any>undefined;
        data["EventParticipantId"] = this.eventParticipantId;
        data["EventParticipant"] = this.eventParticipant ? this.eventParticipant.toJSON() : <any>undefined;
        data["PaymentGatewayId"] = this.paymentGatewayId;
        data["PaymentGateway"] = this.paymentGateway ? this.paymentGateway.toJSON() : <any>undefined;
        data["ActionId"] = this.actionId;
        data["Action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["PostingDate"] = this.postingDate ? this.postingDate.toISOString() : <any>undefined;
        data["ValueDate"] = this.valueDate ? this.valueDate.toISOString() : <any>undefined;
        data["Text"] = this.text;
        data["Amount"] = this.amount;
        data["Units"] = this.units;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["LedgerPostedAt"] = this.ledgerPostedAt ? this.ledgerPostedAt.toISOString() : <any>undefined;
        data["LedgerBlgNr"] = this.ledgerBlgNr;
        data["LedgerOPNr"] = this.ledgerOPNr;
        data["PaymentReference"] = this.paymentReference;
        data["Posted"] = this.posted;
        data["ReversedAt"] = this.reversedAt ? this.reversedAt.toISOString() : <any>undefined;
        data["ReversedById"] = this.reversedById;
        data["ReversedBy"] = this.reversedBy ? this.reversedBy.toJSON() : <any>undefined;
        data["Reversed"] = this.reversed;
        data["IsReversal"] = this.isReversal;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPosting {
    organisationId?: number | undefined;
    organisation?: Organisation | undefined;
    eventId?: string | undefined;
    event?: Event | undefined;
    resourceId?: number | undefined;
    resource?: Resource | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriptionInstance?: SubscriptionInstance | undefined;
    eventParticipantId?: number | undefined;
    eventParticipant?: EventParticipant | undefined;
    paymentGatewayId?: number | undefined;
    paymentGateway?: PaymentGateway | undefined;
    actionId?: number | undefined;
    action?: DomainAction | undefined;
    postingDate?: Date | undefined;
    valueDate?: Date | undefined;
    text?: string | undefined;
    amount?: number | undefined;
    units?: number | undefined;
    ledgerAccountNoDebit?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    ledgerPostedAt?: Date | undefined;
    ledgerBlgNr?: string | undefined;
    ledgerOPNr?: string | undefined;
    paymentReference?: string | undefined;
    posted?: boolean | undefined;
    reversedAt?: Date | undefined;
    reversedById?: string | undefined;
    reversedBy?: User | undefined;
    reversed?: boolean | undefined;
    isReversal?: boolean | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class Organisation implements IOrganisation {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly shortName?: string | undefined;
    readonly organisationTypeId?: number | undefined;
    readonly organisationType?: OrganisationType | undefined;
    readonly addressLine1?: string | undefined;
    readonly addressLine2?: string | undefined;
    readonly addressLine3?: string | undefined;
    readonly addressLine4?: string | undefined;
    readonly addressPrintableHTML?: string | undefined;
    readonly mailFrom?: string | undefined;
    readonly mailHeader?: string | undefined;
    readonly mailHeaderML?: KeyValuePairOfStringAndString[] | undefined;
    readonly mailFooter?: string | undefined;
    readonly mailFooterML?: KeyValuePairOfStringAndString[] | undefined;
    readonly mailServiceApiKey?: string | undefined;
    readonly mailServiceURL?: string | undefined;
    readonly ledgerAccountNoDebit?: string | undefined;
    eSRAccountNoPrint?: string | undefined;
    readonly eSRAccountNo?: string | undefined;
    readonly eSRBankRef?: string | undefined;
    readonly eSRFilePath?: string | undefined;
    readonly ledgerPath?: string | undefined;
    readonly ledgerAccountNoCommon?: string | undefined;
    readonly ledgerVATCode?: string | undefined;
    readonly vATNo?: string | undefined;
    readonly bannerFile?: string | undefined;
    readonly bannerDirectory?: string | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IOrganisation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).shortName = data["ShortName"];
            (<any>this).organisationTypeId = data["OrganisationTypeId"];
            (<any>this).organisationType = data["OrganisationType"] ? OrganisationType.fromJS(data["OrganisationType"]) : <any>undefined;
            (<any>this).addressLine1 = data["AddressLine1"];
            (<any>this).addressLine2 = data["AddressLine2"];
            (<any>this).addressLine3 = data["AddressLine3"];
            (<any>this).addressLine4 = data["AddressLine4"];
            (<any>this).addressPrintableHTML = data["AddressPrintableHTML"];
            (<any>this).mailFrom = data["MailFrom"];
            (<any>this).mailHeader = data["MailHeader"];
            if (data["MailHeaderML"] && data["MailHeaderML"].constructor === Array) {
                (<any>this).mailHeaderML = [];
                for (let item of data["MailHeaderML"])
                    (<any>this).mailHeaderML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).mailFooter = data["MailFooter"];
            if (data["MailFooterML"] && data["MailFooterML"].constructor === Array) {
                (<any>this).mailFooterML = [];
                for (let item of data["MailFooterML"])
                    (<any>this).mailFooterML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).mailServiceApiKey = data["MailServiceApiKey"];
            (<any>this).mailServiceURL = data["MailServiceURL"];
            (<any>this).ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            this.eSRAccountNoPrint = data["ESRAccountNoPrint"];
            (<any>this).eSRAccountNo = data["ESRAccountNo"];
            (<any>this).eSRBankRef = data["ESRBankRef"];
            (<any>this).eSRFilePath = data["ESRFilePath"];
            (<any>this).ledgerPath = data["LedgerPath"];
            (<any>this).ledgerAccountNoCommon = data["LedgerAccountNoCommon"];
            (<any>this).ledgerVATCode = data["LedgerVATCode"];
            (<any>this).vATNo = data["VATNo"];
            (<any>this).bannerFile = data["BannerFile"];
            (<any>this).bannerDirectory = data["BannerDirectory"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Organisation {
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["ShortName"] = this.shortName;
        data["OrganisationTypeId"] = this.organisationTypeId;
        data["OrganisationType"] = this.organisationType ? this.organisationType.toJSON() : <any>undefined;
        data["AddressLine1"] = this.addressLine1;
        data["AddressLine2"] = this.addressLine2;
        data["AddressLine3"] = this.addressLine3;
        data["AddressLine4"] = this.addressLine4;
        data["AddressPrintableHTML"] = this.addressPrintableHTML;
        data["MailFrom"] = this.mailFrom;
        data["MailHeader"] = this.mailHeader;
        if (this.mailHeaderML && this.mailHeaderML.constructor === Array) {
            data["MailHeaderML"] = [];
            for (let item of this.mailHeaderML)
                data["MailHeaderML"].push(item.toJSON());
        }
        data["MailFooter"] = this.mailFooter;
        if (this.mailFooterML && this.mailFooterML.constructor === Array) {
            data["MailFooterML"] = [];
            for (let item of this.mailFooterML)
                data["MailFooterML"].push(item.toJSON());
        }
        data["MailServiceApiKey"] = this.mailServiceApiKey;
        data["MailServiceURL"] = this.mailServiceURL;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["ESRAccountNoPrint"] = this.eSRAccountNoPrint;
        data["ESRAccountNo"] = this.eSRAccountNo;
        data["ESRBankRef"] = this.eSRBankRef;
        data["ESRFilePath"] = this.eSRFilePath;
        data["LedgerPath"] = this.ledgerPath;
        data["LedgerAccountNoCommon"] = this.ledgerAccountNoCommon;
        data["LedgerVATCode"] = this.ledgerVATCode;
        data["VATNo"] = this.vATNo;
        data["BannerFile"] = this.bannerFile;
        data["BannerDirectory"] = this.bannerDirectory;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrganisation {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    shortName?: string | undefined;
    organisationTypeId?: number | undefined;
    organisationType?: OrganisationType | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    addressPrintableHTML?: string | undefined;
    mailFrom?: string | undefined;
    mailHeader?: string | undefined;
    mailHeaderML?: KeyValuePairOfStringAndString[] | undefined;
    mailFooter?: string | undefined;
    mailFooterML?: KeyValuePairOfStringAndString[] | undefined;
    mailServiceApiKey?: string | undefined;
    mailServiceURL?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    eSRAccountNoPrint?: string | undefined;
    eSRAccountNo?: string | undefined;
    eSRBankRef?: string | undefined;
    eSRFilePath?: string | undefined;
    ledgerPath?: string | undefined;
    ledgerAccountNoCommon?: string | undefined;
    ledgerVATCode?: string | undefined;
    vATNo?: string | undefined;
    bannerFile?: string | undefined;
    bannerDirectory?: string | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class Event implements IEvent {
    readonly allDay?: boolean | undefined;
    readonly description?: string | undefined;
    readonly start?: Date | undefined;
    readonly end?: Date | undefined;
    readonly type?: number | undefined;
    readonly location?: string | undefined;
    readonly recurrence?: string | undefined;
    readonly status?: number | undefined;
    readonly subject?: string | undefined;
    readonly reminderInfo?: string | undefined;
    readonly eventType?: EventType | undefined;
    readonly eventTypeId?: number | undefined;
    readonly public?: boolean | undefined;
    recurrenceFirstDate?: Date | undefined;
    recurrenceLastDate?: Date | undefined;
    readonly participants?: EventParticipant[] | undefined;
    readonly resources?: EventResource[] | undefined;
    readonly postings?: Posting[] | undefined;
    readonly deletedResourcesCount?: number | undefined;
    readonly eventsDeleted?: EventDeleted[] | undefined;
    readonly resourceIds?: string | undefined;
    patternId?: string | undefined;
    readonly resourceTextHTML?: string | undefined;
    readonly tarifLevel?: number | undefined;
    readonly participantId?: string | undefined;
    readonly subscriptionInstanceId?: number | undefined;
    readonly id?: string | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).allDay = data["AllDay"];
            (<any>this).description = data["Description"];
            (<any>this).start = data["Start"] ? new Date(data["Start"].toString()) : <any>undefined;
            (<any>this).end = data["End"] ? new Date(data["End"].toString()) : <any>undefined;
            (<any>this).type = data["Type"];
            (<any>this).location = data["Location"];
            (<any>this).recurrence = data["Recurrence"];
            (<any>this).status = data["Status"];
            (<any>this).subject = data["Subject"];
            (<any>this).reminderInfo = data["ReminderInfo"];
            (<any>this).eventType = data["EventType"] ? EventType.fromJS(data["EventType"]) : <any>undefined;
            (<any>this).eventTypeId = data["EventTypeId"];
            (<any>this).public = data["Public"];
            this.recurrenceFirstDate = data["RecurrenceFirstDate"] ? new Date(data["RecurrenceFirstDate"].toString()) : <any>undefined;
            this.recurrenceLastDate = data["RecurrenceLastDate"] ? new Date(data["RecurrenceLastDate"].toString()) : <any>undefined;
            if (data["Participants"] && data["Participants"].constructor === Array) {
                (<any>this).participants = [];
                for (let item of data["Participants"])
                    (<any>this).participants.push(EventParticipant.fromJS(item));
            }
            if (data["Resources"] && data["Resources"].constructor === Array) {
                (<any>this).resources = [];
                for (let item of data["Resources"])
                    (<any>this).resources.push(EventResource.fromJS(item));
            }
            if (data["Postings"] && data["Postings"].constructor === Array) {
                (<any>this).postings = [];
                for (let item of data["Postings"])
                    (<any>this).postings.push(Posting.fromJS(item));
            }
            (<any>this).deletedResourcesCount = data["DeletedResourcesCount"];
            if (data["EventsDeleted"] && data["EventsDeleted"].constructor === Array) {
                (<any>this).eventsDeleted = [];
                for (let item of data["EventsDeleted"])
                    (<any>this).eventsDeleted.push(EventDeleted.fromJS(item));
            }
            (<any>this).resourceIds = data["ResourceIds"];
            this.patternId = data["PatternId"];
            (<any>this).resourceTextHTML = data["ResourceTextHTML"];
            (<any>this).tarifLevel = data["TarifLevel"];
            (<any>this).participantId = data["ParticipantId"];
            (<any>this).subscriptionInstanceId = data["SubscriptionInstanceId"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AllDay"] = this.allDay;
        data["Description"] = this.description;
        data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["End"] = this.end ? this.end.toISOString() : <any>undefined;
        data["Type"] = this.type;
        data["Location"] = this.location;
        data["Recurrence"] = this.recurrence;
        data["Status"] = this.status;
        data["Subject"] = this.subject;
        data["ReminderInfo"] = this.reminderInfo;
        data["EventType"] = this.eventType ? this.eventType.toJSON() : <any>undefined;
        data["EventTypeId"] = this.eventTypeId;
        data["Public"] = this.public;
        data["RecurrenceFirstDate"] = this.recurrenceFirstDate ? this.recurrenceFirstDate.toISOString() : <any>undefined;
        data["RecurrenceLastDate"] = this.recurrenceLastDate ? this.recurrenceLastDate.toISOString() : <any>undefined;
        if (this.participants && this.participants.constructor === Array) {
            data["Participants"] = [];
            for (let item of this.participants)
                data["Participants"].push(item.toJSON());
        }
        if (this.resources && this.resources.constructor === Array) {
            data["Resources"] = [];
            for (let item of this.resources)
                data["Resources"].push(item.toJSON());
        }
        if (this.postings && this.postings.constructor === Array) {
            data["Postings"] = [];
            for (let item of this.postings)
                data["Postings"].push(item.toJSON());
        }
        data["DeletedResourcesCount"] = this.deletedResourcesCount;
        if (this.eventsDeleted && this.eventsDeleted.constructor === Array) {
            data["EventsDeleted"] = [];
            for (let item of this.eventsDeleted)
                data["EventsDeleted"].push(item.toJSON());
        }
        data["ResourceIds"] = this.resourceIds;
        data["PatternId"] = this.patternId;
        data["ResourceTextHTML"] = this.resourceTextHTML;
        data["TarifLevel"] = this.tarifLevel;
        data["ParticipantId"] = this.participantId;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEvent {
    allDay?: boolean | undefined;
    description?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    type?: number | undefined;
    location?: string | undefined;
    recurrence?: string | undefined;
    status?: number | undefined;
    subject?: string | undefined;
    reminderInfo?: string | undefined;
    eventType?: EventType | undefined;
    eventTypeId?: number | undefined;
    public?: boolean | undefined;
    recurrenceFirstDate?: Date | undefined;
    recurrenceLastDate?: Date | undefined;
    participants?: EventParticipant[] | undefined;
    resources?: EventResource[] | undefined;
    postings?: Posting[] | undefined;
    deletedResourcesCount?: number | undefined;
    eventsDeleted?: EventDeleted[] | undefined;
    resourceIds?: string | undefined;
    patternId?: string | undefined;
    resourceTextHTML?: string | undefined;
    tarifLevel?: number | undefined;
    participantId?: string | undefined;
    subscriptionInstanceId?: number | undefined;
    id?: string | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class Resource implements IResource {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly image?: string | undefined;
    readonly color?: string | undefined;
    readonly organisation?: Organisation | undefined;
    readonly organisationId?: number | undefined;
    readonly parentId?: number | undefined;
    readonly parent?: Resource | undefined;
    readonly allocationStrategy?: ResourceAllocationStrategy | undefined;
    readonly allocationPriority?: number | undefined;
    readonly needFreeEvent?: boolean | undefined;
    readonly resourcePersonId?: string | undefined;
    readonly resourcePerson?: User | undefined;
    readonly kNXGroupId?: string | undefined;
    readonly kNXDelayBeforeStart?: string | undefined;
    readonly kNXDelayAfterEnd?: string | undefined;
    readonly displayHostName?: string | undefined;
    readonly displayMacAddress?: string | undefined;
    readonly ledgerAccountNoCredit?: string | undefined;
    readonly bannerFile?: string | undefined;
    readonly children?: Resource[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).image = data["Image"];
            (<any>this).color = data["Color"];
            (<any>this).organisation = data["Organisation"] ? Organisation.fromJS(data["Organisation"]) : <any>undefined;
            (<any>this).organisationId = data["OrganisationId"];
            (<any>this).parentId = data["ParentId"];
            (<any>this).parent = data["Parent"] ? Resource.fromJS(data["Parent"]) : <any>undefined;
            (<any>this).allocationStrategy = data["AllocationStrategy"];
            (<any>this).allocationPriority = data["AllocationPriority"];
            (<any>this).needFreeEvent = data["NeedFreeEvent"];
            (<any>this).resourcePersonId = data["ResourcePersonId"];
            (<any>this).resourcePerson = data["ResourcePerson"] ? User.fromJS(data["ResourcePerson"]) : <any>undefined;
            (<any>this).kNXGroupId = data["KNXGroupId"];
            (<any>this).kNXDelayBeforeStart = data["KNXDelayBeforeStart"];
            (<any>this).kNXDelayAfterEnd = data["KNXDelayAfterEnd"];
            (<any>this).displayHostName = data["DisplayHostName"];
            (<any>this).displayMacAddress = data["DisplayMacAddress"];
            (<any>this).ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            (<any>this).bannerFile = data["BannerFile"];
            if (data["Children"] && data["Children"].constructor === Array) {
                (<any>this).children = [];
                for (let item of data["Children"])
                    (<any>this).children.push(Resource.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Resource {
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["Image"] = this.image;
        data["Color"] = this.color;
        data["Organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["OrganisationId"] = this.organisationId;
        data["ParentId"] = this.parentId;
        data["Parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["AllocationStrategy"] = this.allocationStrategy;
        data["AllocationPriority"] = this.allocationPriority;
        data["NeedFreeEvent"] = this.needFreeEvent;
        data["ResourcePersonId"] = this.resourcePersonId;
        data["ResourcePerson"] = this.resourcePerson ? this.resourcePerson.toJSON() : <any>undefined;
        data["KNXGroupId"] = this.kNXGroupId;
        data["KNXDelayBeforeStart"] = this.kNXDelayBeforeStart;
        data["KNXDelayAfterEnd"] = this.kNXDelayAfterEnd;
        data["DisplayHostName"] = this.displayHostName;
        data["DisplayMacAddress"] = this.displayMacAddress;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["BannerFile"] = this.bannerFile;
        if (this.children && this.children.constructor === Array) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResource {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    image?: string | undefined;
    color?: string | undefined;
    organisation?: Organisation | undefined;
    organisationId?: number | undefined;
    parentId?: number | undefined;
    parent?: Resource | undefined;
    allocationStrategy?: ResourceAllocationStrategy | undefined;
    allocationPriority?: number | undefined;
    needFreeEvent?: boolean | undefined;
    resourcePersonId?: string | undefined;
    resourcePerson?: User | undefined;
    kNXGroupId?: string | undefined;
    kNXDelayBeforeStart?: string | undefined;
    kNXDelayAfterEnd?: string | undefined;
    displayHostName?: string | undefined;
    displayMacAddress?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    bannerFile?: string | undefined;
    children?: Resource[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class SubscriptionInstance implements ISubscriptionInstance {
    readonly subscription?: Subscription | undefined;
    readonly subscriptionId?: number | undefined;
    readonly cost?: number | undefined;
    readonly rebate?: number | undefined;
    readonly costNet?: number | undefined;
    readonly unitsStartBalance?: number | undefined;
    readonly unitsDiscountedAtStart?: number | undefined;
    readonly unitsBalance?: number | undefined;
    readonly startDate?: Date | undefined;
    readonly cancelDate?: Date | undefined;
    readonly cancelledById?: string | undefined;
    readonly cancelledBy?: User | undefined;
    readonly expiryDate?: Date | undefined;
    readonly expiredBy?: User | undefined;
    readonly expiredById?: string | undefined;
    readonly cancelledReason?: string | undefined;
    readonly confirmedDate?: Date | undefined;
    readonly confirmedBy?: User | undefined;
    readonly confirmedById?: string | undefined;
    readonly active?: boolean | undefined;
    readonly eSRCodingLine?: string | undefined;
    readonly oPNr?: string | undefined;
    readonly postings?: Posting[] | undefined;
    readonly postingsBalance?: number | undefined;
    readonly postingsBalanced?: boolean | undefined;
    readonly reminderLevel?: number | undefined;
    readonly reminderDate?: Date | undefined;
    readonly untisBalanceBelowThreshold?: boolean | undefined;
    readonly unitsBalanceTextHTML?: string | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: ISubscriptionInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).subscription = data["Subscription"] ? Subscription.fromJS(data["Subscription"]) : <any>undefined;
            (<any>this).subscriptionId = data["SubscriptionId"];
            (<any>this).cost = data["Cost"];
            (<any>this).rebate = data["Rebate"];
            (<any>this).costNet = data["CostNet"];
            (<any>this).unitsStartBalance = data["UnitsStartBalance"];
            (<any>this).unitsDiscountedAtStart = data["UnitsDiscountedAtStart"];
            (<any>this).unitsBalance = data["UnitsBalance"];
            (<any>this).startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            (<any>this).cancelDate = data["CancelDate"] ? new Date(data["CancelDate"].toString()) : <any>undefined;
            (<any>this).cancelledById = data["CancelledById"];
            (<any>this).cancelledBy = data["CancelledBy"] ? User.fromJS(data["CancelledBy"]) : <any>undefined;
            (<any>this).expiryDate = data["ExpiryDate"] ? new Date(data["ExpiryDate"].toString()) : <any>undefined;
            (<any>this).expiredBy = data["ExpiredBy"] ? User.fromJS(data["ExpiredBy"]) : <any>undefined;
            (<any>this).expiredById = data["ExpiredById"];
            (<any>this).cancelledReason = data["CancelledReason"];
            (<any>this).confirmedDate = data["ConfirmedDate"] ? new Date(data["ConfirmedDate"].toString()) : <any>undefined;
            (<any>this).confirmedBy = data["ConfirmedBy"] ? User.fromJS(data["ConfirmedBy"]) : <any>undefined;
            (<any>this).confirmedById = data["ConfirmedById"];
            (<any>this).active = data["Active"];
            (<any>this).eSRCodingLine = data["ESRCodingLine"];
            (<any>this).oPNr = data["OPNr"];
            if (data["Postings"] && data["Postings"].constructor === Array) {
                (<any>this).postings = [];
                for (let item of data["Postings"])
                    (<any>this).postings.push(Posting.fromJS(item));
            }
            (<any>this).postingsBalance = data["PostingsBalance"];
            (<any>this).postingsBalanced = data["PostingsBalanced"];
            (<any>this).reminderLevel = data["ReminderLevel"];
            (<any>this).reminderDate = data["ReminderDate"] ? new Date(data["ReminderDate"].toString()) : <any>undefined;
            (<any>this).untisBalanceBelowThreshold = data["UntisBalanceBelowThreshold"];
            (<any>this).unitsBalanceTextHTML = data["UnitsBalanceTextHTML"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionInstance {
        let result = new SubscriptionInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["SubscriptionId"] = this.subscriptionId;
        data["Cost"] = this.cost;
        data["Rebate"] = this.rebate;
        data["CostNet"] = this.costNet;
        data["UnitsStartBalance"] = this.unitsStartBalance;
        data["UnitsDiscountedAtStart"] = this.unitsDiscountedAtStart;
        data["UnitsBalance"] = this.unitsBalance;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["CancelDate"] = this.cancelDate ? this.cancelDate.toISOString() : <any>undefined;
        data["CancelledById"] = this.cancelledById;
        data["CancelledBy"] = this.cancelledBy ? this.cancelledBy.toJSON() : <any>undefined;
        data["ExpiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["ExpiredBy"] = this.expiredBy ? this.expiredBy.toJSON() : <any>undefined;
        data["ExpiredById"] = this.expiredById;
        data["CancelledReason"] = this.cancelledReason;
        data["ConfirmedDate"] = this.confirmedDate ? this.confirmedDate.toISOString() : <any>undefined;
        data["ConfirmedBy"] = this.confirmedBy ? this.confirmedBy.toJSON() : <any>undefined;
        data["ConfirmedById"] = this.confirmedById;
        data["Active"] = this.active;
        data["ESRCodingLine"] = this.eSRCodingLine;
        data["OPNr"] = this.oPNr;
        if (this.postings && this.postings.constructor === Array) {
            data["Postings"] = [];
            for (let item of this.postings)
                data["Postings"].push(item.toJSON());
        }
        data["PostingsBalance"] = this.postingsBalance;
        data["PostingsBalanced"] = this.postingsBalanced;
        data["ReminderLevel"] = this.reminderLevel;
        data["ReminderDate"] = this.reminderDate ? this.reminderDate.toISOString() : <any>undefined;
        data["UntisBalanceBelowThreshold"] = this.untisBalanceBelowThreshold;
        data["UnitsBalanceTextHTML"] = this.unitsBalanceTextHTML;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubscriptionInstance {
    subscription?: Subscription | undefined;
    subscriptionId?: number | undefined;
    cost?: number | undefined;
    rebate?: number | undefined;
    costNet?: number | undefined;
    unitsStartBalance?: number | undefined;
    unitsDiscountedAtStart?: number | undefined;
    unitsBalance?: number | undefined;
    startDate?: Date | undefined;
    cancelDate?: Date | undefined;
    cancelledById?: string | undefined;
    cancelledBy?: User | undefined;
    expiryDate?: Date | undefined;
    expiredBy?: User | undefined;
    expiredById?: string | undefined;
    cancelledReason?: string | undefined;
    confirmedDate?: Date | undefined;
    confirmedBy?: User | undefined;
    confirmedById?: string | undefined;
    active?: boolean | undefined;
    eSRCodingLine?: string | undefined;
    oPNr?: string | undefined;
    postings?: Posting[] | undefined;
    postingsBalance?: number | undefined;
    postingsBalanced?: boolean | undefined;
    reminderLevel?: number | undefined;
    reminderDate?: Date | undefined;
    untisBalanceBelowThreshold?: boolean | undefined;
    unitsBalanceTextHTML?: string | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EventParticipant implements IEventParticipant {
    readonly eventId?: string | undefined;
    readonly event?: Event | undefined;
    readonly participantId?: string | undefined;
    readonly participant?: User | undefined;
    readonly subscriptionInstanceId?: number | undefined;
    readonly subscriptionInstance?: SubscriptionInstance | undefined;
    readonly resourceCost?: number | undefined;
    readonly eventCost?: number | undefined;
    readonly rebate?: number | undefined;
    readonly postings?: Posting[] | undefined;
    readonly costNet?: number | undefined;
    readonly cost?: number | undefined;
    readonly selectedActions?: string | undefined;
    readonly actions?: EventParticipantAction[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEventParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).eventId = data["EventId"];
            (<any>this).event = data["Event"] ? Event.fromJS(data["Event"]) : <any>undefined;
            (<any>this).participantId = data["ParticipantId"];
            (<any>this).participant = data["Participant"] ? User.fromJS(data["Participant"]) : <any>undefined;
            (<any>this).subscriptionInstanceId = data["SubscriptionInstanceId"];
            (<any>this).subscriptionInstance = data["SubscriptionInstance"] ? SubscriptionInstance.fromJS(data["SubscriptionInstance"]) : <any>undefined;
            (<any>this).resourceCost = data["ResourceCost"];
            (<any>this).eventCost = data["EventCost"];
            (<any>this).rebate = data["Rebate"];
            if (data["Postings"] && data["Postings"].constructor === Array) {
                (<any>this).postings = [];
                for (let item of data["Postings"])
                    (<any>this).postings.push(Posting.fromJS(item));
            }
            (<any>this).costNet = data["CostNet"];
            (<any>this).cost = data["Cost"];
            (<any>this).selectedActions = data["SelectedActions"];
            if (data["Actions"] && data["Actions"].constructor === Array) {
                (<any>this).actions = [];
                for (let item of data["Actions"])
                    (<any>this).actions.push(EventParticipantAction.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventParticipant {
        let result = new EventParticipant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventId"] = this.eventId;
        data["Event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["ParticipantId"] = this.participantId;
        data["Participant"] = this.participant ? this.participant.toJSON() : <any>undefined;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["SubscriptionInstance"] = this.subscriptionInstance ? this.subscriptionInstance.toJSON() : <any>undefined;
        data["ResourceCost"] = this.resourceCost;
        data["EventCost"] = this.eventCost;
        data["Rebate"] = this.rebate;
        if (this.postings && this.postings.constructor === Array) {
            data["Postings"] = [];
            for (let item of this.postings)
                data["Postings"].push(item.toJSON());
        }
        data["CostNet"] = this.costNet;
        data["Cost"] = this.cost;
        data["SelectedActions"] = this.selectedActions;
        if (this.actions && this.actions.constructor === Array) {
            data["Actions"] = [];
            for (let item of this.actions)
                data["Actions"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventParticipant {
    eventId?: string | undefined;
    event?: Event | undefined;
    participantId?: string | undefined;
    participant?: User | undefined;
    subscriptionInstanceId?: number | undefined;
    subscriptionInstance?: SubscriptionInstance | undefined;
    resourceCost?: number | undefined;
    eventCost?: number | undefined;
    rebate?: number | undefined;
    postings?: Posting[] | undefined;
    costNet?: number | undefined;
    cost?: number | undefined;
    selectedActions?: string | undefined;
    actions?: EventParticipantAction[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class PaymentGateway implements IPaymentGateway {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly description?: string | undefined;
    readonly descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    readonly instructions?: string | undefined;
    readonly instructionsML?: KeyValuePairOfStringAndString[] | undefined;
    readonly ledgerAccountNoDebit?: string | undefined;
    readonly initiationUrl?: string | undefined;
    readonly localSuccessUrl?: string | undefined;
    readonly localFailureUrl?: string | undefined;
    readonly buttonImageUrl?: string | undefined;
    active?: boolean | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IPaymentGateway) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).description = data["Description"];
            if (data["DescriptionML"] && data["DescriptionML"].constructor === Array) {
                (<any>this).descriptionML = [];
                for (let item of data["DescriptionML"])
                    (<any>this).descriptionML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).instructions = data["Instructions"];
            if (data["InstructionsML"] && data["InstructionsML"].constructor === Array) {
                (<any>this).instructionsML = [];
                for (let item of data["InstructionsML"])
                    (<any>this).instructionsML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            (<any>this).initiationUrl = data["InitiationUrl"];
            (<any>this).localSuccessUrl = data["LocalSuccessUrl"];
            (<any>this).localFailureUrl = data["LocalFailureUrl"];
            (<any>this).buttonImageUrl = data["ButtonImageUrl"];
            this.active = data["Active"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentGateway {
        let result = new PaymentGateway();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["Description"] = this.description;
        if (this.descriptionML && this.descriptionML.constructor === Array) {
            data["DescriptionML"] = [];
            for (let item of this.descriptionML)
                data["DescriptionML"].push(item.toJSON());
        }
        data["Instructions"] = this.instructions;
        if (this.instructionsML && this.instructionsML.constructor === Array) {
            data["InstructionsML"] = [];
            for (let item of this.instructionsML)
                data["InstructionsML"].push(item.toJSON());
        }
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["InitiationUrl"] = this.initiationUrl;
        data["LocalSuccessUrl"] = this.localSuccessUrl;
        data["LocalFailureUrl"] = this.localFailureUrl;
        data["ButtonImageUrl"] = this.buttonImageUrl;
        data["Active"] = this.active;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPaymentGateway {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    description?: string | undefined;
    descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    instructions?: string | undefined;
    instructionsML?: KeyValuePairOfStringAndString[] | undefined;
    ledgerAccountNoDebit?: string | undefined;
    initiationUrl?: string | undefined;
    localSuccessUrl?: string | undefined;
    localFailureUrl?: string | undefined;
    buttonImageUrl?: string | undefined;
    active?: boolean | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class DomainAction implements IDomainAction {
    readonly organisation?: Organisation | undefined;
    readonly organisationId?: number | undefined;
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly description?: string | undefined;
    readonly descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    readonly type?: DomainActionType | undefined;
    readonly command?: string | undefined;
    readonly order?: number | undefined;
    readonly automatic?: boolean | undefined;
    readonly active?: boolean | undefined;
    readonly conditionExpression?: string | undefined;
    readonly actionExpression?: string | undefined;
    readonly showUnits?: boolean | undefined;
    readonly messageTo?: string | undefined;
    readonly messageFrom?: string | undefined;
    readonly messageCC?: string | undefined;
    readonly messageBcc?: string | undefined;
    readonly messageSubject?: string | undefined;
    readonly messageSubjectML?: KeyValuePairOfStringAndString[] | undefined;
    readonly messageBody?: string | undefined;
    readonly messageBodyML?: KeyValuePairOfStringAndString[] | undefined;
    readonly actionFailedMessage?: string | undefined;
    readonly actionFailedMessageML?: KeyValuePairOfStringAndString[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IDomainAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).organisation = data["Organisation"] ? Organisation.fromJS(data["Organisation"]) : <any>undefined;
            (<any>this).organisationId = data["OrganisationId"];
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).description = data["Description"];
            if (data["DescriptionML"] && data["DescriptionML"].constructor === Array) {
                (<any>this).descriptionML = [];
                for (let item of data["DescriptionML"])
                    (<any>this).descriptionML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).type = data["Type"];
            (<any>this).command = data["Command"];
            (<any>this).order = data["Order"];
            (<any>this).automatic = data["Automatic"];
            (<any>this).active = data["Active"];
            (<any>this).conditionExpression = data["ConditionExpression"];
            (<any>this).actionExpression = data["ActionExpression"];
            (<any>this).showUnits = data["ShowUnits"];
            (<any>this).messageTo = data["MessageTo"];
            (<any>this).messageFrom = data["MessageFrom"];
            (<any>this).messageCC = data["MessageCC"];
            (<any>this).messageBcc = data["MessageBcc"];
            (<any>this).messageSubject = data["MessageSubject"];
            if (data["MessageSubjectML"] && data["MessageSubjectML"].constructor === Array) {
                (<any>this).messageSubjectML = [];
                for (let item of data["MessageSubjectML"])
                    (<any>this).messageSubjectML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).messageBody = data["MessageBody"];
            if (data["MessageBodyML"] && data["MessageBodyML"].constructor === Array) {
                (<any>this).messageBodyML = [];
                for (let item of data["MessageBodyML"])
                    (<any>this).messageBodyML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).actionFailedMessage = data["ActionFailedMessage"];
            if (data["ActionFailedMessageML"] && data["ActionFailedMessageML"].constructor === Array) {
                (<any>this).actionFailedMessageML = [];
                for (let item of data["ActionFailedMessageML"])
                    (<any>this).actionFailedMessageML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainAction {
        let result = new DomainAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["OrganisationId"] = this.organisationId;
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["Description"] = this.description;
        if (this.descriptionML && this.descriptionML.constructor === Array) {
            data["DescriptionML"] = [];
            for (let item of this.descriptionML)
                data["DescriptionML"].push(item.toJSON());
        }
        data["Type"] = this.type;
        data["Command"] = this.command;
        data["Order"] = this.order;
        data["Automatic"] = this.automatic;
        data["Active"] = this.active;
        data["ConditionExpression"] = this.conditionExpression;
        data["ActionExpression"] = this.actionExpression;
        data["ShowUnits"] = this.showUnits;
        data["MessageTo"] = this.messageTo;
        data["MessageFrom"] = this.messageFrom;
        data["MessageCC"] = this.messageCC;
        data["MessageBcc"] = this.messageBcc;
        data["MessageSubject"] = this.messageSubject;
        if (this.messageSubjectML && this.messageSubjectML.constructor === Array) {
            data["MessageSubjectML"] = [];
            for (let item of this.messageSubjectML)
                data["MessageSubjectML"].push(item.toJSON());
        }
        data["MessageBody"] = this.messageBody;
        if (this.messageBodyML && this.messageBodyML.constructor === Array) {
            data["MessageBodyML"] = [];
            for (let item of this.messageBodyML)
                data["MessageBodyML"].push(item.toJSON());
        }
        data["ActionFailedMessage"] = this.actionFailedMessage;
        if (this.actionFailedMessageML && this.actionFailedMessageML.constructor === Array) {
            data["ActionFailedMessageML"] = [];
            for (let item of this.actionFailedMessageML)
                data["ActionFailedMessageML"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDomainAction {
    organisation?: Organisation | undefined;
    organisationId?: number | undefined;
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    description?: string | undefined;
    descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    type?: DomainActionType | undefined;
    command?: string | undefined;
    order?: number | undefined;
    automatic?: boolean | undefined;
    active?: boolean | undefined;
    conditionExpression?: string | undefined;
    actionExpression?: string | undefined;
    showUnits?: boolean | undefined;
    messageTo?: string | undefined;
    messageFrom?: string | undefined;
    messageCC?: string | undefined;
    messageBcc?: string | undefined;
    messageSubject?: string | undefined;
    messageSubjectML?: KeyValuePairOfStringAndString[] | undefined;
    messageBody?: string | undefined;
    messageBodyML?: KeyValuePairOfStringAndString[] | undefined;
    actionFailedMessage?: string | undefined;
    actionFailedMessageML?: KeyValuePairOfStringAndString[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class User implements IUser {
    firstName?: string | undefined;
    lastName?: string | undefined;
    companyName?: string | undefined;
    birthdate?: Date | undefined;
    student?: boolean | undefined;
    readonly junior?: boolean | undefined;
    studentConfirmedDate?: Date | undefined;
    studentConfirmedBy?: User | undefined;
    studentLegitimation?: string | undefined;
    lastActivityDate?: Date | undefined;
    registrationDate?: Date | undefined;
    address?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    readonly addressPrintable?: string | undefined;
    externalId?: string | undefined;
    intId?: number | undefined;
    externalSystem?: string | undefined;
    readonly name?: string | undefined;
    mailMessages?: EmailMessage[] | undefined;
    subscriptions?: Subscription[] | undefined;
    subscriptionDelegations?: SubscriptionDelegation[] | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEndDateUtc?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;
    readonly roles?: IdentityUserRole[] | undefined;
    readonly claims?: IdentityUserClaim[] | undefined;
    readonly logins?: IdentityUserLogin[] | undefined;
    id?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.companyName = data["CompanyName"];
            this.birthdate = data["Birthdate"] ? new Date(data["Birthdate"].toString()) : <any>undefined;
            this.student = data["Student"];
            (<any>this).junior = data["Junior"];
            this.studentConfirmedDate = data["StudentConfirmedDate"] ? new Date(data["StudentConfirmedDate"].toString()) : <any>undefined;
            this.studentConfirmedBy = data["StudentConfirmedBy"] ? User.fromJS(data["StudentConfirmedBy"]) : <any>undefined;
            this.studentLegitimation = data["StudentLegitimation"];
            this.lastActivityDate = data["LastActivityDate"] ? new Date(data["LastActivityDate"].toString()) : <any>undefined;
            this.registrationDate = data["RegistrationDate"] ? new Date(data["RegistrationDate"].toString()) : <any>undefined;
            this.address = data["Address"];
            this.postalCode = data["PostalCode"];
            this.city = data["City"];
            this.country = data["Country"];
            (<any>this).addressPrintable = data["AddressPrintable"];
            this.externalId = data["ExternalId"];
            this.intId = data["IntId"];
            this.externalSystem = data["ExternalSystem"];
            (<any>this).name = data["Name"];
            if (data["MailMessages"] && data["MailMessages"].constructor === Array) {
                this.mailMessages = [];
                for (let item of data["MailMessages"])
                    this.mailMessages.push(EmailMessage.fromJS(item));
            }
            if (data["Subscriptions"] && data["Subscriptions"].constructor === Array) {
                this.subscriptions = [];
                for (let item of data["Subscriptions"])
                    this.subscriptions.push(Subscription.fromJS(item));
            }
            if (data["SubscriptionDelegations"] && data["SubscriptionDelegations"].constructor === Array) {
                this.subscriptionDelegations = [];
                for (let item of data["SubscriptionDelegations"])
                    this.subscriptionDelegations.push(SubscriptionDelegation.fromJS(item));
            }
            this.email = data["Email"];
            this.emailConfirmed = data["EmailConfirmed"];
            this.passwordHash = data["PasswordHash"];
            this.securityStamp = data["SecurityStamp"];
            this.phoneNumber = data["PhoneNumber"];
            this.phoneNumberConfirmed = data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = data["TwoFactorEnabled"];
            this.lockoutEndDateUtc = data["LockoutEndDateUtc"] ? new Date(data["LockoutEndDateUtc"].toString()) : <any>undefined;
            this.lockoutEnabled = data["LockoutEnabled"];
            this.accessFailedCount = data["AccessFailedCount"];
            if (data["Roles"] && data["Roles"].constructor === Array) {
                (<any>this).roles = [];
                for (let item of data["Roles"])
                    (<any>this).roles.push(IdentityUserRole.fromJS(item));
            }
            if (data["Claims"] && data["Claims"].constructor === Array) {
                (<any>this).claims = [];
                for (let item of data["Claims"])
                    (<any>this).claims.push(IdentityUserClaim.fromJS(item));
            }
            if (data["Logins"] && data["Logins"].constructor === Array) {
                (<any>this).logins = [];
                for (let item of data["Logins"])
                    (<any>this).logins.push(IdentityUserLogin.fromJS(item));
            }
            this.id = data["Id"];
            this.userName = data["UserName"];
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["CompanyName"] = this.companyName;
        data["Birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["Student"] = this.student;
        data["Junior"] = this.junior;
        data["StudentConfirmedDate"] = this.studentConfirmedDate ? this.studentConfirmedDate.toISOString() : <any>undefined;
        data["StudentConfirmedBy"] = this.studentConfirmedBy ? this.studentConfirmedBy.toJSON() : <any>undefined;
        data["StudentLegitimation"] = this.studentLegitimation;
        data["LastActivityDate"] = this.lastActivityDate ? this.lastActivityDate.toISOString() : <any>undefined;
        data["RegistrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["Address"] = this.address;
        data["PostalCode"] = this.postalCode;
        data["City"] = this.city;
        data["Country"] = this.country;
        data["AddressPrintable"] = this.addressPrintable;
        data["ExternalId"] = this.externalId;
        data["IntId"] = this.intId;
        data["ExternalSystem"] = this.externalSystem;
        data["Name"] = this.name;
        if (this.mailMessages && this.mailMessages.constructor === Array) {
            data["MailMessages"] = [];
            for (let item of this.mailMessages)
                data["MailMessages"].push(item.toJSON());
        }
        if (this.subscriptions && this.subscriptions.constructor === Array) {
            data["Subscriptions"] = [];
            for (let item of this.subscriptions)
                data["Subscriptions"].push(item.toJSON());
        }
        if (this.subscriptionDelegations && this.subscriptionDelegations.constructor === Array) {
            data["SubscriptionDelegations"] = [];
            for (let item of this.subscriptionDelegations)
                data["SubscriptionDelegations"].push(item.toJSON());
        }
        data["Email"] = this.email;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        if (this.roles && this.roles.constructor === Array) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        if (this.logins && this.logins.constructor === Array) {
            data["Logins"] = [];
            for (let item of this.logins)
                data["Logins"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        return data; 
    }
}

export interface IUser {
    firstName?: string | undefined;
    lastName?: string | undefined;
    companyName?: string | undefined;
    birthdate?: Date | undefined;
    student?: boolean | undefined;
    junior?: boolean | undefined;
    studentConfirmedDate?: Date | undefined;
    studentConfirmedBy?: User | undefined;
    studentLegitimation?: string | undefined;
    lastActivityDate?: Date | undefined;
    registrationDate?: Date | undefined;
    address?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    addressPrintable?: string | undefined;
    externalId?: string | undefined;
    intId?: number | undefined;
    externalSystem?: string | undefined;
    name?: string | undefined;
    mailMessages?: EmailMessage[] | undefined;
    subscriptions?: Subscription[] | undefined;
    subscriptionDelegations?: SubscriptionDelegation[] | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEndDateUtc?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;
    roles?: IdentityUserRole[] | undefined;
    claims?: IdentityUserClaim[] | undefined;
    logins?: IdentityUserLogin[] | undefined;
    id?: string | undefined;
    userName?: string | undefined;
}

export class KeyValuePairOfStringAndString implements IKeyValuePairOfStringAndString {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IKeyValuePairOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndString {
        let result = new KeyValuePairOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePairOfStringAndString {
    key?: string | undefined;
    value?: string | undefined;
}

export class OrganisationType implements IOrganisationType {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IOrganisationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganisationType {
        let result = new OrganisationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrganisationType {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EventType implements IEventType {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly maxParticipants?: number | undefined;
    readonly minParticipants?: number | undefined;
    readonly priceCalculationType?: EventTypePriceCalculationType | undefined;
    readonly organisation?: Organisation | undefined;
    readonly organisationId?: number | undefined;
    readonly color?: string | undefined;
    readonly bookingSubscriptionTypes?: SubscriptionType[] | undefined;
    readonly ledgerAccountNoCredit?: string | undefined;
    readonly cancellationTerms?: string | undefined;
    readonly cancellationTermsML?: KeyValuePairOfStringAndString[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEventType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).maxParticipants = data["MaxParticipants"];
            (<any>this).minParticipants = data["MinParticipants"];
            (<any>this).priceCalculationType = data["PriceCalculationType"];
            (<any>this).organisation = data["Organisation"] ? Organisation.fromJS(data["Organisation"]) : <any>undefined;
            (<any>this).organisationId = data["OrganisationId"];
            (<any>this).color = data["Color"];
            if (data["BookingSubscriptionTypes"] && data["BookingSubscriptionTypes"].constructor === Array) {
                (<any>this).bookingSubscriptionTypes = [];
                for (let item of data["BookingSubscriptionTypes"])
                    (<any>this).bookingSubscriptionTypes.push(SubscriptionType.fromJS(item));
            }
            (<any>this).ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            (<any>this).cancellationTerms = data["CancellationTerms"];
            if (data["CancellationTermsML"] && data["CancellationTermsML"].constructor === Array) {
                (<any>this).cancellationTermsML = [];
                for (let item of data["CancellationTermsML"])
                    (<any>this).cancellationTermsML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventType {
        let result = new EventType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["MaxParticipants"] = this.maxParticipants;
        data["MinParticipants"] = this.minParticipants;
        data["PriceCalculationType"] = this.priceCalculationType;
        data["Organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["OrganisationId"] = this.organisationId;
        data["Color"] = this.color;
        if (this.bookingSubscriptionTypes && this.bookingSubscriptionTypes.constructor === Array) {
            data["BookingSubscriptionTypes"] = [];
            for (let item of this.bookingSubscriptionTypes)
                data["BookingSubscriptionTypes"].push(item.toJSON());
        }
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["CancellationTerms"] = this.cancellationTerms;
        if (this.cancellationTermsML && this.cancellationTermsML.constructor === Array) {
            data["CancellationTermsML"] = [];
            for (let item of this.cancellationTermsML)
                data["CancellationTermsML"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventType {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    maxParticipants?: number | undefined;
    minParticipants?: number | undefined;
    priceCalculationType?: EventTypePriceCalculationType | undefined;
    organisation?: Organisation | undefined;
    organisationId?: number | undefined;
    color?: string | undefined;
    bookingSubscriptionTypes?: SubscriptionType[] | undefined;
    ledgerAccountNoCredit?: string | undefined;
    cancellationTerms?: string | undefined;
    cancellationTermsML?: KeyValuePairOfStringAndString[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EventResource implements IEventResource {
    readonly eventId?: string | undefined;
    readonly event?: Event | undefined;
    readonly resourceId?: number | undefined;
    readonly resource?: Resource | undefined;
    readonly resourceCost?: number | undefined;
    readonly resourceRebate?: number | undefined;
    readonly resourceCostNet?: number | undefined;
    readonly nrResourcesRequested?: number | undefined;
    readonly interOrganisationPostingsCreated?: boolean | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEventResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).eventId = data["EventId"];
            (<any>this).event = data["Event"] ? Event.fromJS(data["Event"]) : <any>undefined;
            (<any>this).resourceId = data["ResourceId"];
            (<any>this).resource = data["Resource"] ? Resource.fromJS(data["Resource"]) : <any>undefined;
            (<any>this).resourceCost = data["ResourceCost"];
            (<any>this).resourceRebate = data["ResourceRebate"];
            (<any>this).resourceCostNet = data["ResourceCostNet"];
            (<any>this).nrResourcesRequested = data["NrResourcesRequested"];
            (<any>this).interOrganisationPostingsCreated = data["InterOrganisationPostingsCreated"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventResource {
        let result = new EventResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventId"] = this.eventId;
        data["Event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["ResourceId"] = this.resourceId;
        data["Resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["ResourceCost"] = this.resourceCost;
        data["ResourceRebate"] = this.resourceRebate;
        data["ResourceCostNet"] = this.resourceCostNet;
        data["NrResourcesRequested"] = this.nrResourcesRequested;
        data["InterOrganisationPostingsCreated"] = this.interOrganisationPostingsCreated;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventResource {
    eventId?: string | undefined;
    event?: Event | undefined;
    resourceId?: number | undefined;
    resource?: Resource | undefined;
    resourceCost?: number | undefined;
    resourceRebate?: number | undefined;
    resourceCostNet?: number | undefined;
    nrResourcesRequested?: number | undefined;
    interOrganisationPostingsCreated?: boolean | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EventDeleted implements IEventDeleted {
    readonly newEvent?: Event | undefined;
    readonly newEventId?: string | undefined;
    readonly deletedEvent?: Event | undefined;
    readonly deletedEventId?: string | undefined;
    readonly originalEvent?: Event | undefined;
    readonly originalEventId?: string | undefined;
    originalEventOccurrenceId?: number | undefined;
    readonly newExceptionEvent?: Event | undefined;
    readonly newExceptionEventId?: string | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEventDeleted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).newEvent = data["NewEvent"] ? Event.fromJS(data["NewEvent"]) : <any>undefined;
            (<any>this).newEventId = data["NewEventId"];
            (<any>this).deletedEvent = data["DeletedEvent"] ? Event.fromJS(data["DeletedEvent"]) : <any>undefined;
            (<any>this).deletedEventId = data["DeletedEventId"];
            (<any>this).originalEvent = data["OriginalEvent"] ? Event.fromJS(data["OriginalEvent"]) : <any>undefined;
            (<any>this).originalEventId = data["OriginalEventId"];
            this.originalEventOccurrenceId = data["OriginalEventOccurrenceId"];
            (<any>this).newExceptionEvent = data["NewExceptionEvent"] ? Event.fromJS(data["NewExceptionEvent"]) : <any>undefined;
            (<any>this).newExceptionEventId = data["NewExceptionEventId"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventDeleted {
        let result = new EventDeleted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewEvent"] = this.newEvent ? this.newEvent.toJSON() : <any>undefined;
        data["NewEventId"] = this.newEventId;
        data["DeletedEvent"] = this.deletedEvent ? this.deletedEvent.toJSON() : <any>undefined;
        data["DeletedEventId"] = this.deletedEventId;
        data["OriginalEvent"] = this.originalEvent ? this.originalEvent.toJSON() : <any>undefined;
        data["OriginalEventId"] = this.originalEventId;
        data["OriginalEventOccurrenceId"] = this.originalEventOccurrenceId;
        data["NewExceptionEvent"] = this.newExceptionEvent ? this.newExceptionEvent.toJSON() : <any>undefined;
        data["NewExceptionEventId"] = this.newExceptionEventId;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventDeleted {
    newEvent?: Event | undefined;
    newEventId?: string | undefined;
    deletedEvent?: Event | undefined;
    deletedEventId?: string | undefined;
    originalEvent?: Event | undefined;
    originalEventId?: string | undefined;
    originalEventOccurrenceId?: number | undefined;
    newExceptionEvent?: Event | undefined;
    newExceptionEventId?: string | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class Subscription implements ISubscription {
    readonly typeId?: number | undefined;
    readonly type?: SubscriptionType | undefined;
    readonly subscriberId?: string | undefined;
    readonly subscriber?: User | undefined;
    readonly instances?: SubscriptionInstance[] | undefined;
    readonly delegations?: SubscriptionDelegation[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).typeId = data["TypeId"];
            (<any>this).type = data["Type"] ? SubscriptionType.fromJS(data["Type"]) : <any>undefined;
            (<any>this).subscriberId = data["SubscriberId"];
            (<any>this).subscriber = data["Subscriber"] ? User.fromJS(data["Subscriber"]) : <any>undefined;
            if (data["Instances"] && data["Instances"].constructor === Array) {
                (<any>this).instances = [];
                for (let item of data["Instances"])
                    (<any>this).instances.push(SubscriptionInstance.fromJS(item));
            }
            if (data["Delegations"] && data["Delegations"].constructor === Array) {
                (<any>this).delegations = [];
                for (let item of data["Delegations"])
                    (<any>this).delegations.push(SubscriptionDelegation.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Subscription {
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TypeId"] = this.typeId;
        data["Type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["SubscriberId"] = this.subscriberId;
        data["Subscriber"] = this.subscriber ? this.subscriber.toJSON() : <any>undefined;
        if (this.instances && this.instances.constructor === Array) {
            data["Instances"] = [];
            for (let item of this.instances)
                data["Instances"].push(item.toJSON());
        }
        if (this.delegations && this.delegations.constructor === Array) {
            data["Delegations"] = [];
            for (let item of this.delegations)
                data["Delegations"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubscription {
    typeId?: number | undefined;
    type?: SubscriptionType | undefined;
    subscriberId?: string | undefined;
    subscriber?: User | undefined;
    instances?: SubscriptionInstance[] | undefined;
    delegations?: SubscriptionDelegation[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EventParticipantAction implements IEventParticipantAction {
    readonly eventParticipant?: EventParticipant | undefined;
    readonly eventParticipantId?: number | undefined;
    readonly domainAction?: DomainAction | undefined;
    readonly domainActionId?: number | undefined;
    readonly amount?: number | undefined;
    readonly comment?: string | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEventParticipantAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).eventParticipant = data["EventParticipant"] ? EventParticipant.fromJS(data["EventParticipant"]) : <any>undefined;
            (<any>this).eventParticipantId = data["EventParticipantId"];
            (<any>this).domainAction = data["DomainAction"] ? DomainAction.fromJS(data["DomainAction"]) : <any>undefined;
            (<any>this).domainActionId = data["DomainActionId"];
            (<any>this).amount = data["Amount"];
            (<any>this).comment = data["Comment"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventParticipantAction {
        let result = new EventParticipantAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventParticipant"] = this.eventParticipant ? this.eventParticipant.toJSON() : <any>undefined;
        data["EventParticipantId"] = this.eventParticipantId;
        data["DomainAction"] = this.domainAction ? this.domainAction.toJSON() : <any>undefined;
        data["DomainActionId"] = this.domainActionId;
        data["Amount"] = this.amount;
        data["Comment"] = this.comment;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventParticipantAction {
    eventParticipant?: EventParticipant | undefined;
    eventParticipantId?: number | undefined;
    domainAction?: DomainAction | undefined;
    domainActionId?: number | undefined;
    amount?: number | undefined;
    comment?: string | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class EmailMessage implements IEmailMessage {
    readonly userId?: string | undefined;
    readonly user?: User | undefined;
    readonly action?: string | undefined;
    readonly to?: string | undefined;
    readonly from?: string | undefined;
    readonly subject?: string | undefined;
    readonly body?: string | undefined;
    readonly isBodyHtml?: boolean | undefined;
    readonly sendOnUtc?: Date | undefined;
    readonly sentOnUtc?: Date | undefined;
    readonly cancelledOnUtc?: Date | undefined;
    readonly lastSendError?: string | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: IEmailMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).userId = data["UserId"];
            (<any>this).user = data["User"] ? User.fromJS(data["User"]) : <any>undefined;
            (<any>this).action = data["Action"];
            (<any>this).to = data["To"];
            (<any>this).from = data["From"];
            (<any>this).subject = data["Subject"];
            (<any>this).body = data["Body"];
            (<any>this).isBodyHtml = data["IsBodyHtml"];
            (<any>this).sendOnUtc = data["SendOnUtc"] ? new Date(data["SendOnUtc"].toString()) : <any>undefined;
            (<any>this).sentOnUtc = data["SentOnUtc"] ? new Date(data["SentOnUtc"].toString()) : <any>undefined;
            (<any>this).cancelledOnUtc = data["CancelledOnUtc"] ? new Date(data["CancelledOnUtc"].toString()) : <any>undefined;
            (<any>this).lastSendError = data["LastSendError"];
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailMessage {
        let result = new EmailMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["Action"] = this.action;
        data["To"] = this.to;
        data["From"] = this.from;
        data["Subject"] = this.subject;
        data["Body"] = this.body;
        data["IsBodyHtml"] = this.isBodyHtml;
        data["SendOnUtc"] = this.sendOnUtc ? this.sendOnUtc.toISOString() : <any>undefined;
        data["SentOnUtc"] = this.sentOnUtc ? this.sentOnUtc.toISOString() : <any>undefined;
        data["CancelledOnUtc"] = this.cancelledOnUtc ? this.cancelledOnUtc.toISOString() : <any>undefined;
        data["LastSendError"] = this.lastSendError;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEmailMessage {
    userId?: string | undefined;
    user?: User | undefined;
    action?: string | undefined;
    to?: string | undefined;
    from?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isBodyHtml?: boolean | undefined;
    sendOnUtc?: Date | undefined;
    sentOnUtc?: Date | undefined;
    cancelledOnUtc?: Date | undefined;
    lastSendError?: string | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class SubscriptionDelegation implements ISubscriptionDelegation {
    readonly subscriptionId?: number | undefined;
    readonly subscription?: Subscription | undefined;
    readonly delegatedUserId?: string | undefined;
    readonly delegatedUser?: User | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: ISubscriptionDelegation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).subscriptionId = data["SubscriptionId"];
            (<any>this).subscription = data["Subscription"] ? Subscription.fromJS(data["Subscription"]) : <any>undefined;
            (<any>this).delegatedUserId = data["DelegatedUserId"];
            (<any>this).delegatedUser = data["DelegatedUser"] ? User.fromJS(data["DelegatedUser"]) : <any>undefined;
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionDelegation {
        let result = new SubscriptionDelegation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SubscriptionId"] = this.subscriptionId;
        data["Subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["DelegatedUserId"] = this.delegatedUserId;
        data["DelegatedUser"] = this.delegatedUser ? this.delegatedUser.toJSON() : <any>undefined;
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubscriptionDelegation {
    subscriptionId?: number | undefined;
    subscription?: Subscription | undefined;
    delegatedUserId?: string | undefined;
    delegatedUser?: User | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class IdentityUserRole implements IIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;

    constructor(data?: IIdentityUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["UserId"];
            this.roleId = data["RoleId"];
        }
    }

    static fromJS(data: any): IdentityUserRole {
        let result = new IdentityUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["RoleId"] = this.roleId;
        return data; 
    }
}

export interface IIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export class IdentityUserClaim implements IIdentityUserClaim {
    id?: number | undefined;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.userId = data["UserId"];
            this.claimType = data["ClaimType"];
            this.claimValue = data["ClaimValue"];
        }
    }

    static fromJS(data: any): IdentityUserClaim {
        let result = new IdentityUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["ClaimType"] = this.claimType;
        data["ClaimValue"] = this.claimValue;
        return data; 
    }
}

export interface IIdentityUserClaim {
    id?: number | undefined;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class IdentityUserLogin implements IIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IIdentityUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginProvider = data["LoginProvider"];
            this.providerKey = data["ProviderKey"];
            this.userId = data["UserId"];
        }
    }

    static fromJS(data: any): IdentityUserLogin {
        let result = new IdentityUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LoginProvider"] = this.loginProvider;
        data["ProviderKey"] = this.providerKey;
        data["UserId"] = this.userId;
        return data; 
    }
}

export interface IIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    userId?: string | undefined;
}

export class SubscriptionType implements ISubscriptionType {
    readonly title?: string | undefined;
    readonly titleML?: KeyValuePairOfStringAndString[] | undefined;
    readonly description?: string | undefined;
    readonly descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    readonly organisation?: Organisation | undefined;
    readonly organisationId?: number | undefined;
    readonly allowDelegation?: boolean | undefined;
    readonly allowBookingsByUser?: boolean | undefined;
    readonly selfServiceSubscription?: boolean | undefined;
    readonly autoActivate?: boolean | undefined;
    readonly ledgerAccountNoCredit?: string | undefined;
    readonly ledgerAccountNoDebit?: string | undefined;
    readonly cost?: number | undefined;
    readonly prepaid?: boolean | undefined;
    readonly bookableEventTypes?: EventType[] | undefined;
    readonly unitsStartBalance?: number | undefined;
    readonly balanceThreshold?: number | undefined;
    readonly unitPrice?: number | undefined;
    readonly units?: SubscriptionTypeUnits | undefined;
    readonly totalUnits?: number | undefined;
    readonly autoRenew?: boolean | undefined;
    readonly fixedTermEnd?: number | undefined;
    readonly maxDurationDays?: number | undefined;
    readonly rebateRoundExpression?: string | undefined;
    readonly cancellationTerms?: string | undefined;
    readonly cancellationTermsML?: KeyValuePairOfStringAndString[] | undefined;
    readonly renewalTerms?: string | undefined;
    readonly renewalTermsML?: KeyValuePairOfStringAndString[] | undefined;
    readonly id?: number | undefined;
    readonly insertedById?: string | undefined;
    readonly insertedBy?: User | undefined;
    readonly insertedAt?: Date | undefined;
    readonly updatedById?: string | undefined;
    readonly updatedBy?: User | undefined;
    readonly updatedAt?: Date | undefined;

    constructor(data?: ISubscriptionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).title = data["Title"];
            if (data["TitleML"] && data["TitleML"].constructor === Array) {
                (<any>this).titleML = [];
                for (let item of data["TitleML"])
                    (<any>this).titleML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).description = data["Description"];
            if (data["DescriptionML"] && data["DescriptionML"].constructor === Array) {
                (<any>this).descriptionML = [];
                for (let item of data["DescriptionML"])
                    (<any>this).descriptionML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).organisation = data["Organisation"] ? Organisation.fromJS(data["Organisation"]) : <any>undefined;
            (<any>this).organisationId = data["OrganisationId"];
            (<any>this).allowDelegation = data["AllowDelegation"];
            (<any>this).allowBookingsByUser = data["AllowBookingsByUser"];
            (<any>this).selfServiceSubscription = data["SelfServiceSubscription"];
            (<any>this).autoActivate = data["AutoActivate"];
            (<any>this).ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            (<any>this).ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            (<any>this).cost = data["Cost"];
            (<any>this).prepaid = data["Prepaid"];
            if (data["BookableEventTypes"] && data["BookableEventTypes"].constructor === Array) {
                (<any>this).bookableEventTypes = [];
                for (let item of data["BookableEventTypes"])
                    (<any>this).bookableEventTypes.push(EventType.fromJS(item));
            }
            (<any>this).unitsStartBalance = data["UnitsStartBalance"];
            (<any>this).balanceThreshold = data["BalanceThreshold"];
            (<any>this).unitPrice = data["UnitPrice"];
            (<any>this).units = data["Units"];
            (<any>this).totalUnits = data["TotalUnits"];
            (<any>this).autoRenew = data["AutoRenew"];
            (<any>this).fixedTermEnd = data["FixedTermEnd"];
            (<any>this).maxDurationDays = data["MaxDurationDays"];
            (<any>this).rebateRoundExpression = data["RebateRoundExpression"];
            (<any>this).cancellationTerms = data["CancellationTerms"];
            if (data["CancellationTermsML"] && data["CancellationTermsML"].constructor === Array) {
                (<any>this).cancellationTermsML = [];
                for (let item of data["CancellationTermsML"])
                    (<any>this).cancellationTermsML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).renewalTerms = data["RenewalTerms"];
            if (data["RenewalTermsML"] && data["RenewalTermsML"].constructor === Array) {
                (<any>this).renewalTermsML = [];
                for (let item of data["RenewalTermsML"])
                    (<any>this).renewalTermsML.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            (<any>this).id = data["Id"];
            (<any>this).insertedById = data["InsertedById"];
            (<any>this).insertedBy = data["InsertedBy"] ? User.fromJS(data["InsertedBy"]) : <any>undefined;
            (<any>this).insertedAt = data["InsertedAt"] ? new Date(data["InsertedAt"].toString()) : <any>undefined;
            (<any>this).updatedById = data["UpdatedById"];
            (<any>this).updatedBy = data["UpdatedBy"] ? User.fromJS(data["UpdatedBy"]) : <any>undefined;
            (<any>this).updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionType {
        let result = new SubscriptionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        if (this.titleML && this.titleML.constructor === Array) {
            data["TitleML"] = [];
            for (let item of this.titleML)
                data["TitleML"].push(item.toJSON());
        }
        data["Description"] = this.description;
        if (this.descriptionML && this.descriptionML.constructor === Array) {
            data["DescriptionML"] = [];
            for (let item of this.descriptionML)
                data["DescriptionML"].push(item.toJSON());
        }
        data["Organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["OrganisationId"] = this.organisationId;
        data["AllowDelegation"] = this.allowDelegation;
        data["AllowBookingsByUser"] = this.allowBookingsByUser;
        data["SelfServiceSubscription"] = this.selfServiceSubscription;
        data["AutoActivate"] = this.autoActivate;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["Cost"] = this.cost;
        data["Prepaid"] = this.prepaid;
        if (this.bookableEventTypes && this.bookableEventTypes.constructor === Array) {
            data["BookableEventTypes"] = [];
            for (let item of this.bookableEventTypes)
                data["BookableEventTypes"].push(item.toJSON());
        }
        data["UnitsStartBalance"] = this.unitsStartBalance;
        data["BalanceThreshold"] = this.balanceThreshold;
        data["UnitPrice"] = this.unitPrice;
        data["Units"] = this.units;
        data["TotalUnits"] = this.totalUnits;
        data["AutoRenew"] = this.autoRenew;
        data["FixedTermEnd"] = this.fixedTermEnd;
        data["MaxDurationDays"] = this.maxDurationDays;
        data["RebateRoundExpression"] = this.rebateRoundExpression;
        data["CancellationTerms"] = this.cancellationTerms;
        if (this.cancellationTermsML && this.cancellationTermsML.constructor === Array) {
            data["CancellationTermsML"] = [];
            for (let item of this.cancellationTermsML)
                data["CancellationTermsML"].push(item.toJSON());
        }
        data["RenewalTerms"] = this.renewalTerms;
        if (this.renewalTermsML && this.renewalTermsML.constructor === Array) {
            data["RenewalTermsML"] = [];
            for (let item of this.renewalTermsML)
                data["RenewalTermsML"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["InsertedById"] = this.insertedById;
        data["InsertedBy"] = this.insertedBy ? this.insertedBy.toJSON() : <any>undefined;
        data["InsertedAt"] = this.insertedAt ? this.insertedAt.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubscriptionType {
    title?: string | undefined;
    titleML?: KeyValuePairOfStringAndString[] | undefined;
    description?: string | undefined;
    descriptionML?: KeyValuePairOfStringAndString[] | undefined;
    organisation?: Organisation | undefined;
    organisationId?: number | undefined;
    allowDelegation?: boolean | undefined;
    allowBookingsByUser?: boolean | undefined;
    selfServiceSubscription?: boolean | undefined;
    autoActivate?: boolean | undefined;
    ledgerAccountNoCredit?: string | undefined;
    ledgerAccountNoDebit?: string | undefined;
    cost?: number | undefined;
    prepaid?: boolean | undefined;
    bookableEventTypes?: EventType[] | undefined;
    unitsStartBalance?: number | undefined;
    balanceThreshold?: number | undefined;
    unitPrice?: number | undefined;
    units?: SubscriptionTypeUnits | undefined;
    totalUnits?: number | undefined;
    autoRenew?: boolean | undefined;
    fixedTermEnd?: number | undefined;
    maxDurationDays?: number | undefined;
    rebateRoundExpression?: string | undefined;
    cancellationTerms?: string | undefined;
    cancellationTermsML?: KeyValuePairOfStringAndString[] | undefined;
    renewalTerms?: string | undefined;
    renewalTermsML?: KeyValuePairOfStringAndString[] | undefined;
    id?: number | undefined;
    insertedById?: string | undefined;
    insertedBy?: User | undefined;
    insertedAt?: Date | undefined;
    updatedById?: string | undefined;
    updatedBy?: User | undefined;
    updatedAt?: Date | undefined;
}

export class PaymentView implements IPaymentView {
    subscriptionInstanceId?: number | undefined;
    paymentGatewayId?: number | undefined;
    postingDate?: Date | undefined;
    valueDate?: Date | undefined;
    amount?: number | undefined;
    paymentReference?: string | undefined;
    id?: number | undefined;

    constructor(data?: IPaymentView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            this.paymentGatewayId = data["PaymentGatewayId"];
            this.postingDate = data["PostingDate"] ? new Date(data["PostingDate"].toString()) : <any>undefined;
            this.valueDate = data["ValueDate"] ? new Date(data["ValueDate"].toString()) : <any>undefined;
            this.amount = data["Amount"];
            this.paymentReference = data["PaymentReference"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentView {
        let result = new PaymentView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["PaymentGatewayId"] = this.paymentGatewayId;
        data["PostingDate"] = this.postingDate ? this.postingDate.toISOString() : <any>undefined;
        data["ValueDate"] = this.valueDate ? this.valueDate.toISOString() : <any>undefined;
        data["Amount"] = this.amount;
        data["PaymentReference"] = this.paymentReference;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentView {
    subscriptionInstanceId?: number | undefined;
    paymentGatewayId?: number | undefined;
    postingDate?: Date | undefined;
    valueDate?: Date | undefined;
    amount?: number | undefined;
    paymentReference?: string | undefined;
    id?: number | undefined;
}

export class ExecuteActionForSubscription implements IExecuteActionForSubscription {
    principal?: IPrincipal | undefined;
    subscriptionInstanceId?: number | undefined;
    actionId?: number | undefined;
    amount?: number | undefined;
    comment?: string | undefined;

    constructor(data?: IExecuteActionForSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.principal = data["Principal"] ? IPrincipal.fromJS(data["Principal"]) : <any>undefined;
            this.subscriptionInstanceId = data["SubscriptionInstanceId"];
            this.actionId = data["ActionId"];
            this.amount = data["Amount"];
            this.comment = data["Comment"];
        }
    }

    static fromJS(data: any): ExecuteActionForSubscription {
        let result = new ExecuteActionForSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Principal"] = this.principal ? this.principal.toJSON() : <any>undefined;
        data["SubscriptionInstanceId"] = this.subscriptionInstanceId;
        data["ActionId"] = this.actionId;
        data["Amount"] = this.amount;
        data["Comment"] = this.comment;
        return data; 
    }
}

export interface IExecuteActionForSubscription {
    principal?: IPrincipal | undefined;
    subscriptionInstanceId?: number | undefined;
    actionId?: number | undefined;
    amount?: number | undefined;
    comment?: string | undefined;
}

export class IPrincipal implements IIPrincipal {
    readonly identity?: IIdentity | undefined;

    constructor(data?: IIPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).identity = data["Identity"] ? IIdentity.fromJS(data["Identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IPrincipal {
        let result = new IPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIPrincipal {
    identity?: IIdentity | undefined;
}

export class IIdentity implements IIIdentity {
    readonly name?: string | undefined;
    readonly authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean | undefined;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["Name"];
            (<any>this).authenticationType = data["AuthenticationType"];
            (<any>this).isAuthenticated = data["IsAuthenticated"];
        }
    }

    static fromJS(data: any): IIdentity {
        let result = new IIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        return data; 
    }
}

export interface IIIdentity {
    name?: string | undefined;
    authenticationType?: string | undefined;
    isAuthenticated?: boolean | undefined;
}

export class SubscriptionView implements ISubscriptionView {
    typeId?: number | undefined;
    typeTitle?: string | undefined;
    typeOrganisationId?: number | undefined;
    typeOrganisationTitle?: string | undefined;
    subscriberId?: string | undefined;
    subscriberName?: string | undefined;
    subscriberFirstName?: string | undefined;
    subscriberLastName?: string | undefined;
    subscriberStudent?: string | undefined;
    subscriberJunior?: string | undefined;
    subscriberEmail?: string | undefined;
    subscriptionTypePrepaid?: boolean | undefined;
    id?: number | undefined;

    constructor(data?: ISubscriptionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["TypeId"];
            this.typeTitle = data["TypeTitle"];
            this.typeOrganisationId = data["TypeOrganisationId"];
            this.typeOrganisationTitle = data["TypeOrganisationTitle"];
            this.subscriberId = data["SubscriberId"];
            this.subscriberName = data["SubscriberName"];
            this.subscriberFirstName = data["SubscriberFirstName"];
            this.subscriberLastName = data["SubscriberLastName"];
            this.subscriberStudent = data["SubscriberStudent"];
            this.subscriberJunior = data["SubscriberJunior"];
            this.subscriberEmail = data["SubscriberEmail"];
            this.subscriptionTypePrepaid = data["SubscriptionTypePrepaid"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionView {
        let result = new SubscriptionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TypeId"] = this.typeId;
        data["TypeTitle"] = this.typeTitle;
        data["TypeOrganisationId"] = this.typeOrganisationId;
        data["TypeOrganisationTitle"] = this.typeOrganisationTitle;
        data["SubscriberId"] = this.subscriberId;
        data["SubscriberName"] = this.subscriberName;
        data["SubscriberFirstName"] = this.subscriberFirstName;
        data["SubscriberLastName"] = this.subscriberLastName;
        data["SubscriberStudent"] = this.subscriberStudent;
        data["SubscriberJunior"] = this.subscriberJunior;
        data["SubscriberEmail"] = this.subscriberEmail;
        data["SubscriptionTypePrepaid"] = this.subscriptionTypePrepaid;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionView {
    typeId?: number | undefined;
    typeTitle?: string | undefined;
    typeOrganisationId?: number | undefined;
    typeOrganisationTitle?: string | undefined;
    subscriberId?: string | undefined;
    subscriberName?: string | undefined;
    subscriberFirstName?: string | undefined;
    subscriberLastName?: string | undefined;
    subscriberStudent?: string | undefined;
    subscriberJunior?: string | undefined;
    subscriberEmail?: string | undefined;
    subscriptionTypePrepaid?: boolean | undefined;
    id?: number | undefined;
}

export class SubscriptionTypeView implements ISubscriptionTypeView {
    title?: string | undefined;
    description?: string | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    allowDelegation?: boolean | undefined;
    allowBookingsByUser?: boolean | undefined;
    selfServiceSubscription?: boolean | undefined;
    autoActivate?: boolean | undefined;
    confirmBookings?: boolean | undefined;
    ledgerAccountNoDebit?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    cost?: number | undefined;
    prepaid?: boolean | undefined;
    startBalance?: number | undefined;
    balanceThreshold?: number | undefined;
    unitPrice?: number | undefined;
    units?: SubscriptionTypeViewUnits | undefined;
    totalUnits?: number | undefined;
    autoRenew?: boolean | undefined;
    fixedTermEnd?: number | undefined;
    maxDuration?: string | undefined;
    cancellationTerms?: string | undefined;
    renewalTerms?: string | undefined;
    rebateRoundExpression?: string | undefined;
    id?: number | undefined;

    constructor(data?: ISubscriptionTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"];
            this.description = data["Description"];
            this.organisationId = data["OrganisationId"];
            this.organisationTitle = data["OrganisationTitle"];
            this.allowDelegation = data["AllowDelegation"];
            this.allowBookingsByUser = data["AllowBookingsByUser"];
            this.selfServiceSubscription = data["SelfServiceSubscription"];
            this.autoActivate = data["AutoActivate"];
            this.confirmBookings = data["ConfirmBookings"];
            this.ledgerAccountNoDebit = data["LedgerAccountNoDebit"];
            this.ledgerAccountNoCredit = data["LedgerAccountNoCredit"];
            this.cost = data["Cost"];
            this.prepaid = data["Prepaid"];
            this.startBalance = data["StartBalance"];
            this.balanceThreshold = data["BalanceThreshold"];
            this.unitPrice = data["UnitPrice"];
            this.units = data["Units"];
            this.totalUnits = data["TotalUnits"];
            this.autoRenew = data["AutoRenew"];
            this.fixedTermEnd = data["FixedTermEnd"];
            this.maxDuration = data["MaxDuration"];
            this.cancellationTerms = data["CancellationTerms"];
            this.renewalTerms = data["RenewalTerms"];
            this.rebateRoundExpression = data["RebateRoundExpression"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionTypeView {
        let result = new SubscriptionTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["OrganisationId"] = this.organisationId;
        data["OrganisationTitle"] = this.organisationTitle;
        data["AllowDelegation"] = this.allowDelegation;
        data["AllowBookingsByUser"] = this.allowBookingsByUser;
        data["SelfServiceSubscription"] = this.selfServiceSubscription;
        data["AutoActivate"] = this.autoActivate;
        data["ConfirmBookings"] = this.confirmBookings;
        data["LedgerAccountNoDebit"] = this.ledgerAccountNoDebit;
        data["LedgerAccountNoCredit"] = this.ledgerAccountNoCredit;
        data["Cost"] = this.cost;
        data["Prepaid"] = this.prepaid;
        data["StartBalance"] = this.startBalance;
        data["BalanceThreshold"] = this.balanceThreshold;
        data["UnitPrice"] = this.unitPrice;
        data["Units"] = this.units;
        data["TotalUnits"] = this.totalUnits;
        data["AutoRenew"] = this.autoRenew;
        data["FixedTermEnd"] = this.fixedTermEnd;
        data["MaxDuration"] = this.maxDuration;
        data["CancellationTerms"] = this.cancellationTerms;
        data["RenewalTerms"] = this.renewalTerms;
        data["RebateRoundExpression"] = this.rebateRoundExpression;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionTypeView {
    title?: string | undefined;
    description?: string | undefined;
    organisationId?: number | undefined;
    organisationTitle?: string | undefined;
    allowDelegation?: boolean | undefined;
    allowBookingsByUser?: boolean | undefined;
    selfServiceSubscription?: boolean | undefined;
    autoActivate?: boolean | undefined;
    confirmBookings?: boolean | undefined;
    ledgerAccountNoDebit?: string | undefined;
    ledgerAccountNoCredit?: string | undefined;
    cost?: number | undefined;
    prepaid?: boolean | undefined;
    startBalance?: number | undefined;
    balanceThreshold?: number | undefined;
    unitPrice?: number | undefined;
    units?: SubscriptionTypeViewUnits | undefined;
    totalUnits?: number | undefined;
    autoRenew?: boolean | undefined;
    fixedTermEnd?: number | undefined;
    maxDuration?: string | undefined;
    cancellationTerms?: string | undefined;
    renewalTerms?: string | undefined;
    rebateRoundExpression?: string | undefined;
    id?: number | undefined;
}

export class UserView implements IUserView {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    readonly name?: string | undefined;
    readonly text?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    companyName?: string | undefined;
    phoneNumber?: string | undefined;
    birthdate?: Date | undefined;
    address?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    studentConfirmedDate?: Date | undefined;
    studentConfirmedById?: string | undefined;
    studentLegitimation?: string | undefined;
    confirmationUrl?: string | undefined;
    id?: string | undefined;

    constructor(data?: IUserView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["UserName"];
            this.password = data["Password"];
            this.email = data["Email"];
            (<any>this).name = data["Name"];
            (<any>this).text = data["text"];
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.companyName = data["CompanyName"];
            this.phoneNumber = data["PhoneNumber"];
            this.birthdate = data["Birthdate"] ? new Date(data["Birthdate"].toString()) : <any>undefined;
            this.address = data["Address"];
            this.postalCode = data["PostalCode"];
            this.city = data["City"];
            this.country = data["Country"];
            this.junior = data["Junior"];
            this.student = data["Student"];
            this.studentConfirmedDate = data["StudentConfirmedDate"] ? new Date(data["StudentConfirmedDate"].toString()) : <any>undefined;
            this.studentConfirmedById = data["StudentConfirmedById"];
            this.studentLegitimation = data["StudentLegitimation"];
            this.confirmationUrl = data["ConfirmationUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserView {
        let result = new UserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        data["Email"] = this.email;
        data["Name"] = this.name;
        data["text"] = this.text;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["CompanyName"] = this.companyName;
        data["PhoneNumber"] = this.phoneNumber;
        data["Birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["Address"] = this.address;
        data["PostalCode"] = this.postalCode;
        data["City"] = this.city;
        data["Country"] = this.country;
        data["Junior"] = this.junior;
        data["Student"] = this.student;
        data["StudentConfirmedDate"] = this.studentConfirmedDate ? this.studentConfirmedDate.toISOString() : <any>undefined;
        data["StudentConfirmedById"] = this.studentConfirmedById;
        data["StudentLegitimation"] = this.studentLegitimation;
        data["ConfirmationUrl"] = this.confirmationUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserView {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    text?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    companyName?: string | undefined;
    phoneNumber?: string | undefined;
    birthdate?: Date | undefined;
    address?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    junior?: boolean | undefined;
    student?: boolean | undefined;
    studentConfirmedDate?: Date | undefined;
    studentConfirmedById?: string | undefined;
    studentLegitimation?: string | undefined;
    confirmationUrl?: string | undefined;
    id?: string | undefined;
}

export class ResetPasswordView implements IResetPasswordView {
    userId?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
    confirmationUrl?: string | undefined;

    constructor(data?: IResetPasswordView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["UserId"];
            this.email = data["Email"];
            this.token = data["Token"];
            this.password = data["Password"];
            this.confirmationUrl = data["ConfirmationUrl"];
        }
    }

    static fromJS(data: any): ResetPasswordView {
        let result = new ResetPasswordView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["Email"] = this.email;
        data["Token"] = this.token;
        data["Password"] = this.password;
        data["ConfirmationUrl"] = this.confirmationUrl;
        return data; 
    }
}

export interface IResetPasswordView {
    userId?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
    confirmationUrl?: string | undefined;
}

export enum DomainActionViewType {
    _1 = 1, 
    _2 = 2, 
    _10 = 10, 
}

export enum CalendarViewStatusId {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum EventTypeViewPriceCalculationType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum ResourceViewAllocationStrategy {
    _0 = 0, 
    _1 = 1, 
    _100 = 100, 
}

export enum SubscriptionInstanceViewSubscriptionTypeUnits {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
}

export enum ResourceAllocationStrategy {
    _0 = 0, 
    _1 = 1, 
    _100 = 100, 
}

export enum DomainActionType {
    _1 = 1, 
    _2 = 2, 
    _10 = 10, 
}

export enum EventTypePriceCalculationType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum SubscriptionTypeUnits {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
}

export enum SubscriptionTypeViewUnits {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}